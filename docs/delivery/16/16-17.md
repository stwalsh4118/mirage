# [16-17] Write unit tests for authentication middleware and helpers

[Back to task list](./tasks.md)

## Description

Write comprehensive unit tests for the authentication middleware (`RequireAuth`), context helper functions (`GetCurrentUser`, `GetCurrentUserID`), and Clerk client initialization. These tests ensure the authentication layer works correctly in isolation before integration testing.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-07 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |

## Requirements

1. **Middleware Tests** (`auth_test.go`):
   - Test valid JWT verification and user loading
   - Test missing Authorization header
   - Test malformed Authorization header
   - Test invalid JWT signature
   - Test user not found in database
   - Test inactive user
   - Test context population
   - Test LastSeenAt update logic

2. **Context Helper Tests**:
   - Test GetCurrentUser with user in context
   - Test GetCurrentUser without user in context
   - Test GetCurrentUserID with user in context
   - Test GetCurrentUserID without user in context

3. **Mocking Strategy**:
   - Mock Clerk SDK's VerifyToken function
   - Use in-memory database for user queries
   - Mock Gin context for testing

4. **Test Coverage**:
   - Aim for >80% coverage on auth package
   - Cover all error paths
   - Cover all success paths

## Implementation Plan

### Phase 1: Create Test File Structure
```
api/internal/auth/
├── middleware.go
├── context.go
├── clerk.go
├── middleware_test.go  ← Create
├── context_test.go     ← Create
└── clerk_test.go       ← Create (if needed)
```

### Phase 2: Implement Middleware Tests
Create `api/internal/auth/middleware_test.go`:

```go
package auth

import (
    "net/http"
    "net/http/httptest"
    "testing"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/stwalsh4118/mirageapi/internal/store"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
)

func setupTestDB(t *testing.T) *gorm.DB {
    db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
    if err != nil {
        t.Fatalf("failed to open test database: %v", err)
    }
    
    if err := db.AutoMigrate(&store.User{}); err != nil {
        t.Fatalf("failed to migrate: %v", err)
    }
    
    return db
}

func createTestUser(t *testing.T, db *gorm.DB) *store.User {
    user := &store.User{
        ID:          "user-123",
        ClerkUserID: "user_clerk123",
        Email:       "test@example.com",
        IsActive:    true,
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
    }
    
    if err := db.Create(user).Error; err != nil {
        t.Fatalf("failed to create test user: %v", err)
    }
    
    return user
}

func TestRequireAuth_MissingAuthHeader(t *testing.T) {
    db := setupTestDB(t)
    
    gin.SetMode(gin.TestMode)
    w := httptest.NewRecorder()
    c, _ := gin.CreateTestContext(w)
    c.Request = httptest.NewRequest("GET", "/", nil)
    
    middleware := RequireAuth(db)
    middleware(c)
    
    if w.Code != http.StatusUnauthorized {
        t.Errorf("expected 401, got %d", w.Code)
    }
    
    if !c.IsAborted() {
        t.Error("expected request to be aborted")
    }
}

func TestRequireAuth_MalformedAuthHeader(t *testing.T) {
    db := setupTestDB(t)
    
    gin.SetMode(gin.TestMode)
    w := httptest.NewRecorder()
    c, _ := gin.CreateTestContext(w)
    c.Request = httptest.NewRequest("GET", "/", nil)
    c.Request.Header.Set("Authorization", "InvalidFormat")
    
    middleware := RequireAuth(db)
    middleware(c)
    
    if w.Code != http.StatusUnauthorized {
        t.Errorf("expected 401, got %d", w.Code)
    }
}

func TestRequireAuth_ValidToken_UserNotFound(t *testing.T) {
    // Note: This test requires mocking Clerk SDK's VerifyToken
    // Implementation depends on how Clerk SDK is structured
    // May need to refactor middleware to accept VerifyToken as dependency
    
    db := setupTestDB(t)
    
    // Mock successful JWT verification
    // ... mock implementation ...
    
    // Test that user not found returns 404
}

func TestRequireAuth_ValidToken_InactiveUser(t *testing.T) {
    db := setupTestDB(t)
    
    // Create inactive user
    user := createTestUser(t, db)
    user.IsActive = false
    db.Save(user)
    
    // Mock successful JWT verification
    // ... mock implementation ...
    
    // Test that inactive user returns 403
}

func TestRequireAuth_ValidToken_Success(t *testing.T) {
    db := setupTestDB(t)
    createTestUser(t, db)
    
    // Mock successful JWT verification
    // ... mock implementation ...
    
    // Test that user is added to context
    // Test that request continues
}
```

### Phase 3: Implement Context Helper Tests
Create `api/internal/auth/context_test.go`:

```go
package auth

import (
    "testing"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/stwalsh4118/mirageapi/internal/store"
)

func TestGetCurrentUser_Success(t *testing.T) {
    gin.SetMode(gin.TestMode)
    c, _ := gin.CreateTestContext(nil)
    
    expectedUser := &store.User{
        ID:          "user-123",
        ClerkUserID: "user_clerk123",
        Email:       "test@example.com",
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
    }
    
    c.Set(contextKeyUser, expectedUser)
    
    user, err := GetCurrentUser(c)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
    
    if user.ID != expectedUser.ID {
        t.Errorf("expected user ID %s, got %s", expectedUser.ID, user.ID)
    }
}

func TestGetCurrentUser_NotInContext(t *testing.T) {
    gin.SetMode(gin.TestMode)
    c, _ := gin.CreateTestContext(nil)
    
    user, err := GetCurrentUser(c)
    if err == nil {
        t.Error("expected error, got nil")
    }
    
    if user != nil {
        t.Error("expected nil user, got user")
    }
    
    if err != ErrUserNotInContext {
        t.Errorf("expected ErrUserNotInContext, got %v", err)
    }
}

func TestGetCurrentUserID_Success(t *testing.T) {
    gin.SetMode(gin.TestMode)
    c, _ := gin.CreateTestContext(nil)
    
    expectedID := "user-123"
    user := &store.User{
        ID:    expectedID,
        Email: "test@example.com",
    }
    
    c.Set(contextKeyUser, user)
    
    userID, err := GetCurrentUserID(c)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
    
    if userID != expectedID {
        t.Errorf("expected user ID %s, got %s", expectedID, userID)
    }
}

func TestGetCurrentUserID_NotInContext(t *testing.T) {
    gin.SetMode(gin.TestMode)
    c, _ := gin.CreateTestContext(nil)
    
    userID, err := GetCurrentUserID(c)
    if err == nil {
        t.Error("expected error, got nil")
    }
    
    if userID != "" {
        t.Error("expected empty user ID, got value")
    }
}
```

### Phase 4: Run Tests and Check Coverage
```bash
# Run tests
cd api/internal/auth
go test -v

# Check coverage
go test -cover
go test -coverprofile=coverage.out
go tool cover -html=coverage.out

# Aim for >80% coverage
```

## Verification

### Test Implementation Checklist
- [ ] middleware_test.go created with tests
- [ ] context_test.go created with tests
- [ ] All success paths tested
- [ ] All error paths tested
- [ ] Mocking strategy implemented

### Test Coverage Checklist
- [ ] RequireAuth middleware tested
- [ ] GetCurrentUser tested
- [ ] GetCurrentUserID tested
- [ ] Error cases covered
- [ ] Coverage >80%

### Test Quality Checklist
- [ ] Tests are independent (no shared state)
- [ ] Tests use descriptive names
- [ ] Tests have clear arrange/act/assert structure
- [ ] Tests clean up resources
- [ ] Tests run fast

## Test Plan

**Objective**: Verify unit tests cover authentication layer comprehensively

**Test Scope**: Unit tests for auth package

**Test Scenarios**:

All test scenarios are implemented as Go test functions:

1. Missing Authorization header → 401
2. Malformed Authorization header → 401
3. Invalid JWT signature → 401
4. Valid JWT, user not found → 404
5. Valid JWT, inactive user → 403
6. Valid JWT, active user → Success, user in context
7. GetCurrentUser with user → Returns user
8. GetCurrentUser without user → Returns error
9. GetCurrentUserID with user → Returns ID
10. GetCurrentUserID without user → Returns error

**Success Criteria**:
- All tests pass
- Coverage >80%
- Tests run in <1 second
- No flaky tests

## Files Modified

- `api/internal/auth/middleware_test.go` - Create middleware tests
- `api/internal/auth/context_test.go` - Create context helper tests
- `api/internal/auth/clerk_test.go` - Create Clerk client tests (optional)

## Notes

### Mocking Clerk SDK

**Challenge**: Clerk SDK may not have mock-friendly interfaces

**Solutions**:
1. **Wrapper Interface**:
   ```go
   type JWTVerifier interface {
       VerifyToken(token string) (map[string]interface{}, error)
   }
   
   // Production
   type ClerkVerifier struct {
       client *clerk.Client
   }
   
   // Test
   type MockVerifier struct {
       VerifyFunc func(string) (map[string]interface{}, error)
   }
   ```

2. **Dependency Injection**:
   ```go
   func RequireAuth(db *gorm.DB, verifier JWTVerifier) gin.HandlerFunc {
       // Use verifier instead of direct Clerk SDK call
   }
   ```

3. **Test-Only Middleware**:
   ```go
   // For tests that don't need real Clerk
   func RequireAuthTest(db *gorm.DB, userID string) gin.HandlerFunc {
       return func(c *gin.Context) {
           // Load user directly without JWT verification
       }
   }
   ```

### Table-Driven Tests

**Recommended Pattern**:
```go
func TestRequireAuth(t *testing.T) {
    tests := []struct {
        name           string
        authHeader     string
        setupDB        func(*gorm.DB)
        expectedStatus int
        expectedAbort  bool
    }{
        {
            name:           "missing auth header",
            authHeader:     "",
            expectedStatus: 401,
            expectedAbort:  true,
        },
        {
            name:           "malformed auth header",
            authHeader:     "InvalidFormat",
            expectedStatus: 401,
            expectedAbort:  true,
        },
        // ... more test cases ...
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Test implementation
        })
    }
}
```

### Test Database Cleanup

**Best Practice**:
```go
func setupTestDB(t *testing.T) *gorm.DB {
    db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
    if err != nil {
        t.Fatalf("failed to open test database: %v", err)
    }
    
    // Cleanup after test
    t.Cleanup(func() {
        sqlDB, _ := db.DB()
        sqlDB.Close()
    })
    
    return db
}
```

### Testing LastSeenAt Update

**Async Testing**:
```go
func TestLastSeenAtUpdate(t *testing.T) {
    db := setupTestDB(t)
    user := createTestUser(t, db)
    
    // Simulate auth
    // ... 
    
    // Wait for async update
    time.Sleep(100 * time.Millisecond)
    
    // Reload user
    var updated store.User
    db.First(&updated, "id = ?", user.ID)
    
    if updated.LastSeenAt == nil {
        t.Error("expected LastSeenAt to be updated")
    }
}
```

### CI/CD Integration

**GitHub Actions Example**:
```yaml
- name: Run auth package tests
  run: |
    cd api/internal/auth
    go test -v -cover -coverprofile=coverage.out
    go tool cover -func=coverage.out
```

### Integration Dependencies

**Requires**:
- Task 16-5: Middleware and helpers implemented

**Prepares For**:
- Task 16-18: Integration tests (builds on unit tests)
- Task 16-20: E2E tests (requires working auth)

**Coverage**:
- Unit tests (this task)
- Integration tests (task 16-18, 16-19)
- E2E tests (task 16-20)


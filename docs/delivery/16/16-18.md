# [16-18] Write integration tests for webhook handlers

[Back to task list](./tasks.md)

## Description

Write integration tests for the Clerk webhook handler to verify user synchronization works correctly. Test user creation, updates, and deletion via webhook events with real database operations and signature verification.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-07 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |

## Requirements

1. **Webhook Handler Tests**:
   - Test user.created event creates User record
   - Test user.updated event updates User record
   - Test user.deleted event marks User inactive
   - Test signature verification (valid/invalid)
   - Test idempotency (duplicate webhooks)
   - Test malformed payloads
   - Test unknown event types

2. **Test Environment**:
   - Use real database (in-memory SQLite or Postgres)
   - Generate valid webhook signatures
   - Use realistic Clerk payloads
   - Test full HTTP request/response cycle

3. **Test Coverage**:
   - Cover all webhook event types
   - Cover all error cases
   - Cover edge cases (missing fields, etc.)
   - Aim for >80% coverage

## Implementation Plan

### Phase 1: Create Test File
Create `api/internal/webhooks/webhooks_test.go`:

```go
package webhooks

import (
    "bytes"
    "crypto/hmac"
    "crypto/sha256"
    "encoding/hex"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/google/uuid"
    "github.com/stwalsh4118/mirageapi/internal/store"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
)

func setupTestDB(t *testing.T) *gorm.DB {
    db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
    if err != nil {
        t.Fatalf("failed to open test database: %v", err)
    }
    
    if err := db.AutoMigrate(&store.User{}); err != nil {
        t.Fatalf("failed to migrate: %v", err)
    }
    
    t.Cleanup(func() {
        sqlDB, _ := db.DB()
        sqlDB.Close()
    })
    
    return db
}

func generateSignature(payload []byte, secret string) string {
    mac := hmac.New(sha256.New, []byte(secret))
    mac.Write(payload)
    signature := hex.EncodeToString(mac.Sum(nil))
    return "v1," + signature
}

func TestHandleWebhook_UserCreated(t *testing.T) {
    db := setupTestDB(t)
    webhookSecret := "test_secret"
    handler := NewClerkWebhookHandler(db, webhookSecret)
    
    // Create webhook payload
    payload := map[string]interface{}{
        "id":   "evt_" + uuid.New().String(),
        "type": "user.created",
        "data": map[string]interface{}{
            "id":         "user_clerk123",
            "first_name": "John",
            "last_name":  "Doe",
            "image_url":  "https://example.com/avatar.jpg",
            "email_addresses": []map[string]interface{}{
                {
                    "email_address": "john@example.com",
                    "id":            "email_123",
                },
            },
        },
    }
    
    payloadBytes, _ := json.Marshal(payload)
    signature := generateSignature(payloadBytes, webhookSecret)
    
    // Create HTTP request
    gin.SetMode(gin.TestMode)
    w := httptest.NewRecorder()
    c, _ := gin.CreateTestContext(w)
    c.Request = httptest.NewRequest("POST", "/webhooks/clerk", bytes.NewReader(payloadBytes))
    c.Request.Header.Set("svix-signature", signature)
    
    // Handle webhook
    handler.HandleWebhook(c)
    
    // Verify response
    if w.Code != http.StatusOK {
        t.Errorf("expected 200, got %d: %s", w.Code, w.Body.String())
    }
    
    // Verify user created in database
    var user store.User
    err := db.Where("clerk_user_id = ?", "user_clerk123").First(&user).Error
    if err != nil {
        t.Fatalf("user not found in database: %v", err)
    }
    
    if user.Email != "john@example.com" {
        t.Errorf("expected email john@example.com, got %s", user.Email)
    }
    
    if *user.FirstName != "John" {
        t.Errorf("expected first name John, got %s", *user.FirstName)
    }
    
    if !user.IsActive {
        t.Error("expected user to be active")
    }
}

func TestHandleWebhook_UserUpdated(t *testing.T) {
    db := setupTestDB(t)
    webhookSecret := "test_secret"
    handler := NewClerkWebhookHandler(db, webhookSecret)
    
    // Create existing user
    existingUser := &store.User{
        ID:          uuid.New().String(),
        ClerkUserID: "user_clerk123",
        Email:       "old@example.com",
        IsActive:    true,
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
    }
    db.Create(existingUser)
    
    // Create update webhook
    payload := map[string]interface{}{
        "id":   "evt_" + uuid.New().String(),
        "type": "user.updated",
        "data": map[string]interface{}{
            "id":         "user_clerk123",
            "first_name": "Jane",
            "last_name":  "Smith",
            "email_addresses": []map[string]interface{}{
                {
                    "email_address": "jane@example.com",
                },
            },
        },
    }
    
    payloadBytes, _ := json.Marshal(payload)
    signature := generateSignature(payloadBytes, webhookSecret)
    
    // Send webhook
    gin.SetMode(gin.TestMode)
    w := httptest.NewRecorder()
    c, _ := gin.CreateTestContext(w)
    c.Request = httptest.NewRequest("POST", "/webhooks/clerk", bytes.NewReader(payloadBytes))
    c.Request.Header.Set("svix-signature", signature)
    
    handler.HandleWebhook(c)
    
    // Verify response
    if w.Code != http.StatusOK {
        t.Errorf("expected 200, got %d", w.Code)
    }
    
    // Verify user updated
    var updated store.User
    db.Where("clerk_user_id = ?", "user_clerk123").First(&updated)
    
    if updated.Email != "jane@example.com" {
        t.Errorf("expected email jane@example.com, got %s", updated.Email)
    }
    
    if *updated.FirstName != "Jane" {
        t.Errorf("expected first name Jane, got %s", *updated.FirstName)
    }
}

func TestHandleWebhook_UserDeleted(t *testing.T) {
    db := setupTestDB(t)
    webhookSecret := "test_secret"
    handler := NewClerkWebhookHandler(db, webhookSecret)
    
    // Create existing user
    existingUser := &store.User{
        ID:          uuid.New().String(),
        ClerkUserID: "user_clerk123",
        Email:       "delete@example.com",
        IsActive:    true,
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
    }
    db.Create(existingUser)
    
    // Create delete webhook
    payload := map[string]interface{}{
        "id":   "evt_" + uuid.New().String(),
        "type": "user.deleted",
        "data": map[string]interface{}{
            "id": "user_clerk123",
        },
    }
    
    payloadBytes, _ := json.Marshal(payload)
    signature := generateSignature(payloadBytes, webhookSecret)
    
    // Send webhook
    gin.SetMode(gin.TestMode)
    w := httptest.NewRecorder()
    c, _ := gin.CreateTestContext(w)
    c.Request = httptest.NewRequest("POST", "/webhooks/clerk", bytes.NewReader(payloadBytes))
    c.Request.Header.Set("svix-signature", signature)
    
    handler.HandleWebhook(c)
    
    // Verify response
    if w.Code != http.StatusOK {
        t.Errorf("expected 200, got %d", w.Code)
    }
    
    // Verify user marked inactive
    var deleted store.User
    db.Where("clerk_user_id = ?", "user_clerk123").First(&deleted)
    
    if deleted.IsActive {
        t.Error("expected user to be inactive after delete")
    }
}

func TestHandleWebhook_InvalidSignature(t *testing.T) {
    db := setupTestDB(t)
    webhookSecret := "test_secret"
    handler := NewClerkWebhookHandler(db, webhookSecret)
    
    payload := map[string]interface{}{
        "id":   "evt_123",
        "type": "user.created",
        "data": map[string]interface{}{},
    }
    
    payloadBytes, _ := json.Marshal(payload)
    
    // Create invalid signature
    invalidSignature := "v1,invalidsignature"
    
    gin.SetMode(gin.TestMode)
    w := httptest.NewRecorder()
    c, _ := gin.CreateTestContext(w)
    c.Request = httptest.NewRequest("POST", "/webhooks/clerk", bytes.NewReader(payloadBytes))
    c.Request.Header.Set("svix-signature", invalidSignature)
    
    handler.HandleWebhook(c)
    
    // Verify 401 response
    if w.Code != http.StatusUnauthorized {
        t.Errorf("expected 401, got %d", w.Code)
    }
}

func TestHandleWebhook_Idempotency(t *testing.T) {
    db := setupTestDB(t)
    webhookSecret := "test_secret"
    handler := NewClerkWebhookHandler(db, webhookSecret)
    
    webhookID := "evt_" + uuid.New().String()
    
    payload := map[string]interface{}{
        "id":   webhookID,
        "type": "user.created",
        "data": map[string]interface{}{
            "id":    "user_clerk123",
            "email_addresses": []map[string]interface{}{
                {"email_address": "test@example.com"},
            },
        },
    }
    
    payloadBytes, _ := json.Marshal(payload)
    signature := generateSignature(payloadBytes, webhookSecret)
    
    // Send webhook first time
    gin.SetMode(gin.TestMode)
    w1 := httptest.NewRecorder()
    c1, _ := gin.CreateTestContext(w1)
    c1.Request = httptest.NewRequest("POST", "/webhooks/clerk", bytes.NewReader(payloadBytes))
    c1.Request.Header.Set("svix-signature", signature)
    handler.HandleWebhook(c1)
    
    // Count users
    var count1 int64
    db.Model(&store.User{}).Count(&count1)
    
    // Send same webhook again
    w2 := httptest.NewRecorder()
    c2, _ := gin.CreateTestContext(w2)
    c2.Request = httptest.NewRequest("POST", "/webhooks/clerk", bytes.NewReader(payloadBytes))
    c2.Request.Header.Set("svix-signature", signature)
    handler.HandleWebhook(c2)
    
    // Count users again
    var count2 int64
    db.Model(&store.User{}).Count(&count2)
    
    // Verify only one user created
    if count1 != count2 {
        t.Errorf("expected idempotent behavior, got %d users after first call, %d after second", count1, count2)
    }
    
    // Both should return 200
    if w1.Code != http.StatusOK || w2.Code != http.StatusOK {
        t.Error("expected both requests to return 200")
    }
}

func TestHandleWebhook_UnknownEventType(t *testing.T) {
    db := setupTestDB(t)
    webhookSecret := "test_secret"
    handler := NewClerkWebhookHandler(db, webhookSecret)
    
    payload := map[string]interface{}{
        "id":   "evt_" + uuid.New().String(),
        "type": "unknown.event.type",
        "data": map[string]interface{}{},
    }
    
    payloadBytes, _ := json.Marshal(payload)
    signature := generateSignature(payloadBytes, webhookSecret)
    
    gin.SetMode(gin.TestMode)
    w := httptest.NewRecorder()
    c, _ := gin.CreateTestContext(w)
    c.Request = httptest.NewRequest("POST", "/webhooks/clerk", bytes.NewReader(payloadBytes))
    c.Request.Header.Set("svix-signature", signature)
    
    handler.HandleWebhook(c)
    
    // Unknown events should return 200 (skip, don't error)
    if w.Code != http.StatusOK {
        t.Errorf("expected 200 for unknown event, got %d", w.Code)
    }
}
```

### Phase 2: Run Tests
```bash
cd api/internal/webhooks
go test -v
go test -cover
```

## Verification

### Test Coverage Checklist
- [ ] user.created event tested
- [ ] user.updated event tested
- [ ] user.deleted event tested
- [ ] Signature verification tested
- [ ] Idempotency tested
- [ ] Invalid payloads tested
- [ ] Unknown events tested
- [ ] Coverage >80%

### Database Integration Checklist
- [ ] Users created in database
- [ ] Users updated in database
- [ ] Users marked inactive
- [ ] Transactions work correctly
- [ ] No data leaks between tests

## Test Plan

**Objective**: Verify webhook handler integrates correctly with database

**Test Scope**: Integration tests with real database

**Key Test Scenarios**: All implemented as Go test functions

**Success Criteria**:
- All tests pass
- Coverage >80%
- Tests run in <2 seconds
- No flaky tests

## Files Modified

- `api/internal/webhooks/webhooks_test.go` - Create integration tests

## Notes

### Real vs Mock Database

**Use Real Database**:
- Integration tests need real DB operations
- In-memory SQLite is fast enough
- Tests actual GORM queries

### Signature Generation

**Test Signatures**:
- Use same algorithm as Clerk
- HMAC-SHA256
- Test both valid and invalid

### Idempotency Testing

**Important**:
- Test duplicate webhooks
- Verify only one record created/updated
- Cache prevents duplicate processing

### Integration Dependencies

**Requires**:
- Task 16-6: Webhook handler implemented
- Task 16-3: User model exists

**Completes**:
- Webhook handler testing
- Ready for E2E tests


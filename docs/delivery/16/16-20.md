# [16-20] E2E CoS Test: Complete authentication and ownership flow

[Back to task list](./tasks.md)

## Description

Create comprehensive end-to-end tests that verify all Conditions of Satisfaction for PBI 16 are met. Test the complete authentication flow from sign-up through resource creation and ownership isolation, ensuring the entire system works together correctly.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-07 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |

## Requirements

1. **CoS Coverage**:
   - Verify all PBI 16 Conditions of Satisfaction
   - Test complete user journeys
   - Test resource isolation
   - Test error scenarios

2. **Test Scenarios**:
   - User sign-up and sign-in
   - Environment creation with ownership
   - Service creation with ownership
   - Resource listing filtered by user
   - Cross-user access prevention
   - Profile management
   - Sign-out

3. **Test Environment**:
   - Use test Clerk instance or mock
   - Real backend and database
   - Real frontend (or API testing)
   - Clean state between tests

4. **Conditions of Satisfaction**:
   From PRD - verify all 7 categories:
   1. Frontend Clerk Integration
   2. Backend JWT Verification
   3. User Database Model
   4. Resource Ownership
   5. Clerk Webhooks
   6. API Protection
   7. User Profile Management

## Implementation Plan

### Phase 1: Create E2E Test File
Create `api/test/e2e/auth_test.go`:

```go
package e2e

import (
    "bytes"
    "encoding/json"
    "net/http"
    "testing"
    "time"
)

// TestE2E_AuthenticationFlow tests the complete authentication flow
func TestE2E_AuthenticationFlow(t *testing.T) {
    // This test should:
    // 1. Sign up a new user via Clerk
    // 2. Get JWT token
    // 3. Make authenticated API call
    // 4. Verify request succeeds
    
    t.Run("SignUp", func(t *testing.T) {
        // Sign up user
        // Trigger webhook (user.created)
        // Verify user in database
    })
    
    t.Run("SignIn", func(t *testing.T) {
        // Sign in user
        // Get JWT token
        // Verify token is valid
    })
    
    t.Run("AccessProtectedEndpoint", func(t *testing.T) {
        // Make API call with JWT
        // Verify 200 response
        // Verify data returned
    })
}

// TestE2E_ResourceOwnership tests resource ownership isolation
func TestE2E_ResourceOwnership(t *testing.T) {
    // Setup: Create two users
    user1Token := createTestUser(t, "user1@example.com")
    user2Token := createTestUser(t, "user2@example.com")
    
    // User1 creates environment
    envID := createEnvironment(t, user1Token, "user1-env")
    
    // User1 can access their environment
    t.Run("User1_CanAccessOwnEnvironment", func(t *testing.T) {
        resp := getEnvironment(t, user1Token, envID)
        if resp.StatusCode != http.StatusOK {
            t.Errorf("expected 200, got %d", resp.StatusCode)
        }
    })
    
    // User2 cannot access User1's environment
    t.Run("User2_CannotAccessUser1Environment", func(t *testing.T) {
        resp := getEnvironment(t, user2Token, envID)
        if resp.StatusCode != http.StatusNotFound {
            t.Errorf("expected 404, got %d", resp.StatusCode)
        }
    })
    
    // User1 creates service
    svcID := createService(t, user1Token, envID, "user1-service")
    
    // User1 can access their service
    t.Run("User1_CanAccessOwnService", func(t *testing.T) {
        resp := getService(t, user1Token, svcID)
        if resp.StatusCode != http.StatusOK {
            t.Errorf("expected 200, got %d", resp.StatusCode)
        }
    })
    
    // User2 cannot access User1's service
    t.Run("User2_CannotAccessUser1Service", func(t *testing.T) {
        resp := getService(t, user2Token, svcID)
        if resp.StatusCode != http.StatusNotFound {
            t.Errorf("expected 404, got %d", resp.StatusCode)
        }
    })
}

// TestE2E_Webhooks tests webhook user synchronization
func TestE2E_Webhooks(t *testing.T) {
    t.Run("UserCreated", func(t *testing.T) {
        // Simulate Clerk user.created webhook
        // Verify user created in database
        // Verify user can authenticate
    })
    
    t.Run("UserUpdated", func(t *testing.T) {
        // Create user
        // Simulate user.updated webhook
        // Verify user data updated in database
    })
    
    t.Run("UserDeleted", func(t *testing.T) {
        // Create user
        // Simulate user.deleted webhook
        // Verify user marked inactive
        // Verify user cannot authenticate
    })
}

// TestE2E_ProfileManagement tests user profile endpoints
func TestE2E_ProfileManagement(t *testing.T) {
    token := createTestUser(t, "profile@example.com")
    
    t.Run("GetProfile", func(t *testing.T) {
        resp := getProfile(t, token)
        if resp.StatusCode != http.StatusOK {
            t.Errorf("expected 200, got %d", resp.StatusCode)
        }
        
        var profile map[string]interface{}
        json.Unmarshal(resp.Body, &profile)
        
        if profile["email"] != "profile@example.com" {
            t.Error("profile email mismatch")
        }
    })
    
    t.Run("UpdateProfile", func(t *testing.T) {
        updates := map[string]interface{}{
            "firstName": "Jane",
            "lastName":  "Doe",
        }
        
        resp := updateProfile(t, token, updates)
        if resp.StatusCode != http.StatusOK {
            t.Errorf("expected 200, got %d", resp.StatusCode)
        }
        
        // Verify update
        profile := getProfile(t, token)
        var data map[string]interface{}
        json.Unmarshal(profile.Body, &data)
        
        if data["firstName"] != "Jane" {
            t.Error("firstName not updated")
        }
    })
    
    t.Run("ListUserEnvironments", func(t *testing.T) {
        // Create environments
        createEnvironment(t, token, "env1")
        createEnvironment(t, token, "env2")
        
        // List environments
        resp := listUserEnvironments(t, token)
        if resp.StatusCode != http.StatusOK {
            t.Errorf("expected 200, got %d", resp.StatusCode)
        }
        
        var envs []map[string]interface{}
        json.Unmarshal(resp.Body, &envs)
        
        if len(envs) < 2 {
            t.Error("expected at least 2 environments")
        }
    })
}

// TestE2E_APIProtection tests API route protection
func TestE2E_APIProtection(t *testing.T) {
    t.Run("ProtectedRoute_WithoutAuth", func(t *testing.T) {
        // Call protected endpoint without token
        resp := callAPI(t, "GET", "/api/v1/users/me", nil, "")
        
        if resp.StatusCode != http.StatusUnauthorized {
            t.Errorf("expected 401, got %d", resp.StatusCode)
        }
    })
    
    t.Run("ProtectedRoute_WithAuth", func(t *testing.T) {
        token := createTestUser(t, "protected@example.com")
        
        // Call protected endpoint with token
        resp := callAPI(t, "GET", "/api/v1/users/me", nil, token)
        
        if resp.StatusCode != http.StatusOK {
            t.Errorf("expected 200, got %d", resp.StatusCode)
        }
    })
    
    t.Run("PublicRoute_WithoutAuth", func(t *testing.T) {
        // Call health endpoint without token
        resp := callAPI(t, "GET", "/api/v1/healthz", nil, "")
        
        if resp.StatusCode != http.StatusOK {
            t.Errorf("expected 200, got %d", resp.StatusCode)
        }
    })
}

// Helper functions

func createTestUser(t *testing.T, email string) string {
    // Create user via Clerk or webhook simulation
    // Return JWT token
    // Implementation depends on test setup
    return "test_jwt_token"
}

func createEnvironment(t *testing.T, token string, name string) string {
    payload := map[string]interface{}{
        "projectId": "test_project",
        "name":      name,
    }
    
    resp := callAPI(t, "POST", "/api/v1/provision/environment", payload, token)
    
    if resp.StatusCode != http.StatusOK {
        t.Fatalf("failed to create environment: %d", resp.StatusCode)
    }
    
    var result map[string]interface{}
    json.Unmarshal(resp.Body, &result)
    return result["environmentId"].(string)
}

func createService(t *testing.T, token string, envID string, name string) string {
    payload := map[string]interface{}{
        "projectId":     "test_project",
        "environmentId": envID,
        "services": []map[string]interface{}{
            {
                "name":   name,
                "repo":   "github.com/test/repo",
                "branch": "main",
            },
        },
    }
    
    resp := callAPI(t, "POST", "/api/v1/provision/services", payload, token)
    
    if resp.StatusCode != http.StatusOK {
        t.Fatalf("failed to create service: %d", resp.StatusCode)
    }
    
    var result map[string]interface{}
    json.Unmarshal(resp.Body, &result)
    serviceIDs := result["serviceIds"].([]interface{})
    return serviceIDs[0].(string)
}

func getEnvironment(t *testing.T, token string, envID string) *http.Response {
    return callAPI(t, "GET", "/api/v1/environments/"+envID+"/metadata", nil, token)
}

func getService(t *testing.T, token string, svcID string) *http.Response {
    return callAPI(t, "GET", "/api/v1/services/"+svcID, nil, token)
}

func getProfile(t *testing.T, token string) *http.Response {
    return callAPI(t, "GET", "/api/v1/users/me", nil, token)
}

func updateProfile(t *testing.T, token string, updates map[string]interface{}) *http.Response {
    return callAPI(t, "PATCH", "/api/v1/users/me", updates, token)
}

func listUserEnvironments(t *testing.T, token string) *http.Response {
    return callAPI(t, "GET", "/api/v1/users/me/environments", nil, token)
}

func callAPI(t *testing.T, method string, path string, body interface{}, token string) *http.Response {
    var bodyReader *bytes.Reader
    if body != nil {
        bodyBytes, _ := json.Marshal(body)
        bodyReader = bytes.NewReader(bodyBytes)
    }
    
    req, _ := http.NewRequest(method, "http://localhost:8090"+path, bodyReader)
    
    if token != "" {
        req.Header.Set("Authorization", "Bearer "+token)
    }
    
    if body != nil {
        req.Header.Set("Content-Type", "application/json")
    }
    
    client := &http.Client{Timeout: 10 * time.Second}
    resp, err := client.Do(req)
    if err != nil {
        t.Fatalf("API call failed: %v", err)
    }
    
    return resp
}
```

### Phase 2: Create Test Setup Script
Create `api/test/e2e/setup_test.go`:

```go
package e2e

import (
    "os"
    "testing"
)

func TestMain(m *testing.M) {
    // Setup test environment
    setupTestServer()
    setupTestDatabase()
    setupClerkTestMode()
    
    // Run tests
    code := m.Run()
    
    // Cleanup
    teardownTestServer()
    teardownTestDatabase()
    
    os.Exit(code)
}

func setupTestServer() {
    // Start test server
    // Or ensure server is running
}

func setupTestDatabase() {
    // Create test database
    // Run migrations
}

func setupClerkTestMode() {
    // Configure Clerk for testing
    // Use test API keys
}

func teardownTestServer() {
    // Stop test server if started
}

func teardownTestDatabase() {
    // Clean up test database
}
```

### Phase 3: Run E2E Tests
```bash
# Start backend server in test mode
cd api
go run cmd/server/main.go &
SERVER_PID=$!

# Run E2E tests
cd test/e2e
go test -v

# Cleanup
kill $SERVER_PID
```

## Verification

### CoS Coverage Checklist
Map to PRD Conditions of Satisfaction:

**1. Frontend Clerk Integration**:
- [ ] Sign-up and sign-in work
- [ ] JWT tokens sent with requests
- [ ] Authentication state persists

**2. Backend JWT Verification**:
- [ ] Middleware verifies tokens
- [ ] Invalid tokens rejected
- [ ] User loaded correctly

**3. User Database Model**:
- [ ] User table created
- [ ] All fields present
- [ ] Clerk data synchronized

**4. Resource Ownership**:
- [ ] Resources have UserID
- [ ] Users can only access own resources
- [ ] 403 for unauthorized access

**5. Clerk Webhooks**:
- [ ] user.created works
- [ ] user.updated works
- [ ] user.deleted works
- [ ] Idempotent

**6. API Protection**:
- [ ] Protected routes require auth
- [ ] Public routes accessible
- [ ] Appropriate error codes

**7. User Profile Management**:
- [ ] GET /users/me works
- [ ] PATCH /users/me works
- [ ] Resource listing works

## Test Plan

**Objective**: Verify all PBI 16 requirements are met end-to-end

**Test Scope**: Complete system integration

**Test Scenarios**: Implemented as E2E test functions

**Success Criteria**:
- All CoS verified
- All test scenarios pass
- System works end-to-end
- PBI 16 ready for review

## Files Modified

- `api/test/e2e/auth_test.go` - Create E2E authentication tests
- `api/test/e2e/setup_test.go` - Create test setup/teardown
- `api/test/e2e/README.md` - Document E2E test setup and execution

## Notes

### Test Environment Setup

**Requirements**:
- Running backend server
- Test database (separate from dev)
- Clerk test environment or mocks
- Test data fixtures

**Options**:
1. **Real Clerk Test Instance**: Most realistic
2. **Clerk Mocks**: Faster, more control
3. **Hybrid**: Real Clerk for some tests, mocks for others

### Test Data Management

**Clean State**:
- Delete all test data before tests
- Or use separate test database
- Each test should be independent

**Test Users**:
- Create test users dynamically
- Use unique emails (timestamps)
- Clean up after tests

### CI/CD Integration

**GitHub Actions Example**:
```yaml
name: E2E Tests

on: [push, pull_request]

jobs:
  e2e:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Setup Go
        uses: actions/setup-go@v2
        with:
          go-version: '1.21'
      
      - name: Start Backend
        run: |
          cd api
          go run cmd/server/main.go &
          sleep 5
      
      - name: Run E2E Tests
        run: |
          cd api/test/e2e
          go test -v
      
      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v2
        with:
          name: test-results
          path: api/test/e2e/*.out
```

### Alternative: Playwright E2E Tests

**Frontend E2E** (if desired):
```typescript
// web/e2e/auth.spec.ts
import { test, expect } from '@playwright/test';

test('complete authentication flow', async ({ page }) => {
  // Navigate to app
  await page.goto('/');
  
  // Click sign-in
  await page.click('text=Sign In');
  
  // Fill credentials
  await page.fill('input[name=email]', 'test@example.com');
  await page.fill('input[name=password]', 'password123');
  await page.click('button[type=submit]');
  
  // Verify redirected
  await expect(page).toHaveURL('/');
  
  // Verify authenticated
  await expect(page.locator('text=Profile')).toBeVisible();
});
```

### Performance Testing

**Optional Additions**:
- Load testing (multiple concurrent users)
- Stress testing (high request volume)
- Latency measurements
- Not required for MVP, but good to have

### Integration Dependencies

**Requires**:
- All previous tasks complete
- System fully integrated
- Test environment set up

**Completes**:
- PBI 16 implementation
- All CoS verified
- Ready for review and merge


# [16-3] Create User model and database migration

[Back to task list](./tasks.md)

## Description

Create the User GORM model to store Clerk user data locally, define the database schema with appropriate indexes, and implement AutoMigrate to handle database initialization. This model serves as the local representation of Clerk users and enables efficient queries for resource ownership.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-07 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |
| 2025-10-08 00:00:00 | Status Change | Proposed | InProgress | Started implementation of User model and migration | AI Agent |
| 2025-10-08 00:00:00 | Status Change | InProgress | Review | Completed User model with GORM integration and unit tests | AI Agent |
| 2025-10-08 00:00:00 | Status Change | Review | Done | Task completed, User model ready for production | AI Agent |

## Requirements

1. **User Model Fields**:
   - `ID` (UUID, primary key) - Internal Mirage user ID
   - `ClerkUserID` (string, unique, indexed) - Clerk's user ID (e.g., "user_2...")
   - `Email` (string, unique, indexed) - User's email address
   - `FirstName` (string, nullable) - User's first name
   - `LastName` (string, nullable) - User's last name
   - `ProfileImageURL` (string, nullable) - URL to user's profile image
   - `CreatedAt` (timestamp) - When user was created in our system
   - `UpdatedAt` (timestamp) - Last time user data was updated
   - `LastSeenAt` (timestamp, nullable) - Last time user accessed the system
   - `IsActive` (boolean, default true) - Soft delete flag

2. **Database Constraints**:
   - `ClerkUserID` must be unique (database constraint)
   - `Email` must be unique (database constraint)
   - Indexes on `ClerkUserID` and `Email` for fast lookups
   - Index on `IsActive` for filtering active users

3. **GORM Integration**:
   - Add `User` to `store.go` AutoMigrate calls
   - Model should work with both PostgreSQL and SQLite
   - Proper GORM struct tags for all fields

4. **JSON Serialization**:
   - All fields should have appropriate JSON tags
   - Omit sensitive fields from JSON if needed
   - Use snake_case for JSON field names to match API conventions

## Implementation Plan

### Phase 1: Define User Model
1. Create `User` struct in `api/internal/store/models.go`:
   ```go
   type User struct {
       ID              string     `gorm:"primaryKey;type:text" json:"id"`
       ClerkUserID     string     `gorm:"uniqueIndex;not null;type:text" json:"clerkUserId"`
       Email           string     `gorm:"uniqueIndex;not null;type:text" json:"email"`
       FirstName       *string    `gorm:"type:text" json:"firstName,omitempty"`
       LastName        *string    `gorm:"type:text" json:"lastName,omitempty"`
       ProfileImageURL *string    `gorm:"type:text" json:"profileImageUrl,omitempty"`
       CreatedAt       time.Time  `gorm:"index" json:"createdAt"`
       UpdatedAt       time.Time  `json:"updatedAt"`
       LastSeenAt      *time.Time `json:"lastSeenAt,omitempty"`
       IsActive        bool       `gorm:"index;default:true" json:"isActive"`
   }
   ```

2. Consider adding table name method if needed:
   ```go
   func (User) TableName() string {
       return "users"
   }
   ```

### Phase 2: Update AutoMigrate
1. Add `&User{}` to AutoMigrate calls in `api/internal/store/store.go`:
   - In `Open()` function (SQLite path)
   - In `OpenFromURL()` function (PostgreSQL path)

2. Order matters - User should be migrated before models that reference it:
   ```go
   db.AutoMigrate(&User{}, &Environment{}, &Service{}, &EnvironmentMetadata{})
   ```

### Phase 3: Add Helper Methods (Optional)
Consider adding utility methods to the User model:
```go
// FullName returns the user's full name, handling nil values
func (u *User) FullName() string {
    if u.FirstName != nil && u.LastName != nil {
        return *u.FirstName + " " + *u.LastName
    }
    if u.FirstName != nil {
        return *u.FirstName
    }
    if u.LastName != nil {
        return *u.LastName
    }
    return u.Email // Fallback to email
}
```

### Phase 4: Create Unit Tests
1. Create `api/internal/store/user_test.go`:
   - Test creating user with all fields
   - Test creating user with minimal fields (nullables empty)
   - Test unique constraint on ClerkUserID
   - Test unique constraint on Email
   - Test IsActive default value
   - Test LastSeenAt nullable behavior

## Verification

### Model Definition Checklist
- [ ] User struct defined in `models.go`
- [ ] All required fields present with correct types
- [ ] GORM tags correctly set (primaryKey, uniqueIndex, index, etc.)
- [ ] JSON tags use snake_case convention
- [ ] Nullable fields use pointer types
- [ ] Default values specified in GORM tags where appropriate

### Migration Checklist
- [ ] User added to AutoMigrate in both `Open()` and `OpenFromURL()`
- [ ] Migration order is correct (User before models that reference it)
- [ ] Migration runs successfully on SQLite
- [ ] Migration runs successfully on PostgreSQL (if available)

### Testing Checklist
- [ ] Unit tests created in `user_test.go`
- [ ] All tests pass
- [ ] Unique constraints validated
- [ ] Default values validated
- [ ] Nullable fields validated

## Test Plan

**Objective**: Verify User model is correctly defined and can be persisted to database

**Test Scope**: User model CRUD operations and constraints

**Environment & Setup**:
- In-memory SQLite database for tests
- GORM AutoMigrate to create schema

**Test Scenarios**:

1. **Create User with All Fields**
   - Given: User with all fields populated
   - When: User is created in database
   - Then: User is persisted with all fields intact

2. **Create User with Minimal Fields**
   - Given: User with only required fields (ClerkUserID, Email)
   - When: User is created in database
   - Then: User is persisted, nullable fields are nil, IsActive defaults to true

3. **Unique Constraint on ClerkUserID**
   - Given: User with ClerkUserID "user_123" exists
   - When: Attempt to create another user with same ClerkUserID
   - Then: Database returns unique constraint error

4. **Unique Constraint on Email**
   - Given: User with email "test@example.com" exists
   - When: Attempt to create another user with same email
   - Then: Database returns unique constraint error

5. **Update LastSeenAt**
   - Given: Existing user
   - When: LastSeenAt is updated to current time
   - Then: Update succeeds and value is persisted

6. **Soft Delete via IsActive**
   - Given: Active user (IsActive=true)
   - When: IsActive is set to false
   - Then: Update succeeds, user can still be queried but is marked inactive

**Success Criteria**:
- All tests pass
- User records can be created, read, updated
- Unique constraints are enforced
- Nullable fields work correctly
- Default values are applied

## Files Modified

- `api/internal/store/models.go` - Add User model struct
- `api/internal/store/store.go` - Add User to AutoMigrate calls
- `api/internal/store/user_test.go` - Create unit tests for User model

## Notes

### Design Decisions

**UUID for Internal ID**:
- Use UUID for `ID` field (not Clerk's user ID)
- Allows internal referential integrity
- Clerk user ID stored separately in `ClerkUserID` field

**ClerkUserID as String**:
- Clerk user IDs are strings like "user_2abc..."
- Store as-is without parsing
- Indexed for fast lookups during authentication

**Nullable Name Fields**:
- FirstName and LastName are optional in Clerk
- Use pointer types (*string) for proper null handling
- Avoid empty strings vs null ambiguity

**LastSeenAt Tracking**:
- Will be updated by middleware (task 16-5)
- Nullable to distinguish "never seen" from "seen at time X"
- Update frequency will be throttled (max once per hour) to avoid excessive writes

**Soft Delete with IsActive**:
- Instead of hard deleting users, mark IsActive=false
- Preserves audit trail and resource history
- Future PBI could add "orphaned resource" handling

### Integration Points

**Webhooks (16-6)**:
- Webhook handler will create/update User records
- ClerkUserID comes from webhook payload `data.id`
- Email and profile data from webhook payload

**Middleware (16-5)**:
- Middleware verifies JWT, extracts ClerkUserID
- Loads User from database using ClerkUserID
- Returns 404 if user not found (shouldn't happen if webhooks working)

**Foreign Keys (16-4)**:
- Environment, Service, EnvironmentMetadata will reference User.ID
- User must be created before Foreign Key migration runs

### Database Compatibility

**PostgreSQL**:
- `type:text` for string fields
- `uniqueIndex` creates unique index
- `default:true` for boolean fields

**SQLite**:
- Same GORM tags work
- TEXT type for strings
- INTEGER for booleans (0/1)
- Datetime for timestamps

Both databases supported by GORM with same model definition.


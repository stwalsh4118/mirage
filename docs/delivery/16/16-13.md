# [16-13] Add authentication state management and JWT interceptor

[Back to task list](./tasks.md)

## Description

Update the frontend API client to automatically include JWT tokens in all requests, handle 401 responses with redirects to sign-in, and integrate authentication state throughout the application using Clerk's React hooks.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-07 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |
| 2025-10-08 00:00:00 | Status Change | Proposed | InProgress | Started implementation of JWT interceptor and auth state management | AI Agent |
| 2025-10-08 00:00:00 | Status Change | InProgress | Review | Completed JWT interceptor, all hooks updated, build successful | AI Agent |
| 2025-10-08 00:00:00 | Status Change | Review | Done | Task completed, JWT interceptor ready for backend auth | AI Agent |

## Requirements

1. **JWT Token Interceptor**:
   - Get JWT token from Clerk on every API request
   - Add `Authorization: Bearer <token>` header automatically
   - Handle token refresh transparently

2. **401 Response Handling**:
   - Intercept 401 responses from API
   - Redirect to `/sign-in` with return URL
   - Clear local state if needed

3. **Authentication Hooks**:
   - Use `useAuth()` from Clerk for auth state
   - Use `useUser()` for current user data
   - Conditionally render based on auth state

4. **API Client Updates**:
   - Update `fetchJSON` helper to include token
   - Maintain backward compatibility
   - Handle token retrieval errors

## Implementation Plan

### Phase 1: Create Authenticated API Client
Update `web/src/lib/api.ts`:

```typescript
import { useAuth } from '@clerk/nextjs';

export const DEFAULT_API_BASE_URL = "http://localhost:8090";
const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || DEFAULT_API_BASE_URL;

export async function fetchJSON<T>(
  path: string,
  init?: RequestInit,
  token?: string | null
): Promise<T> {
  const url = new URL(path, API_BASE_URL).toString();
  
  const headers = new Headers(init?.headers);
  
  // Add Authorization header if token provided
  if (token) {
    headers.set('Authorization', `Bearer ${token}`);
  }
  
  // Add Content-Type for requests with body
  if (init?.body && !headers.has('Content-Type')) {
    headers.set('Content-Type', 'application/json');
  }
  
  const res = await fetch(url, {
    ...init,
    headers,
    cache: "no-store",
  });
  
  // Handle 204 No Content
  if (res.status === 204) {
    return {} as T;
  }
  
  // Handle 401 Unauthorized
  if (res.status === 401) {
    // Redirect to sign-in if not authenticated
    if (typeof window !== 'undefined') {
      const currentUrl = window.location.pathname + window.location.search;
      window.location.href = `/sign-in?redirect_url=${encodeURIComponent(currentUrl)}`;
    }
    throw new Error('Authentication required');
  }
  
  // Handle other errors
  if (!res.ok) {
    const body = await res.text().catch(() => "");
    throw new Error(`Request failed ${res.status}: ${body}`);
  }
  
  return (await res.json()) as T;
}
```

### Phase 2: Create useAuthenticatedFetch Hook
Create `web/src/hooks/useAuthenticatedFetch.ts`:

```typescript
import { useAuth } from '@clerk/nextjs';
import { useCallback } from 'react';
import { fetchJSON } from '@/lib/api';

export function useAuthenticatedFetch() {
  const { getToken } = useAuth();
  
  const authenticatedFetch = useCallback(
    async <T>(path: string, init?: RequestInit): Promise<T> => {
      // Get JWT token from Clerk
      const token = await getToken();
      
      // Call fetchJSON with token
      return fetchJSON<T>(path, init, token);
    },
    [getToken]
  );
  
  return authenticatedFetch;
}
```

### Phase 3: Update React Query Hooks
Update `web/src/hooks/useRailway.ts` (example):

```typescript
import { useQuery } from '@tanstack/react-query';
import { useAuthenticatedFetch } from './useAuthenticatedFetch';

export function useRailwayProjects(names: string[]) {
  const fetch = useAuthenticatedFetch();
  
  return useQuery({
    queryKey: ['railway', 'projects', ...names],
    queryFn: async () => {
      const url = `/api/v1/railway/projects?${names.map(n => `name=${n}`).join('&')}`;
      return fetch(url);
    },
    enabled: names.length > 0,
  });
}
```

### Phase 4: Create useCurrentUser Hook
Create `web/src/hooks/useCurrentUser.ts`:

```typescript
import { useUser } from '@clerk/nextjs';
import { useQuery } from '@tanstack/react-query';
import { useAuthenticatedFetch } from './useAuthenticatedFetch';

export interface MirageUser {
  id: string;
  clerkUserId: string;
  email: string;
  firstName?: string;
  lastName?: string;
  profileImageUrl?: string;
  lastSeenAt?: string;
  createdAt: string;
  updatedAt: string;
}

export function useCurrentUser() {
  const { isSignedIn } = useUser();
  const fetch = useAuthenticatedFetch();
  
  return useQuery({
    queryKey: ['user', 'me'],
    queryFn: () => fetch<MirageUser>('/api/v1/users/me'),
    enabled: isSignedIn,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}
```

### Phase 5: Update Wizard Store (if needed)
Update `web/src/store/wizard.ts` to use authenticated fetch:

```typescript
// Example: Update provision actions
const fetch = useAuthenticatedFetch(); // Get from hook

async function provisionEnvironment() {
  const response = await fetch('/api/v1/provision/environment', {
    method: 'POST',
    body: JSON.stringify(provisionData),
  });
  return response;
}
```

## Verification

### API Client Checklist
- [ ] fetchJSON accepts optional token parameter
- [ ] Authorization header added when token present
- [ ] 401 responses redirect to sign-in
- [ ] useAuthenticatedFetch hook created
- [ ] Hook uses Clerk's getToken()

### Integration Checklist
- [ ] All API calls use authenticated fetch
- [ ] React Query hooks updated
- [ ] useCurrentUser hook created
- [ ] Wizard store updated (if applicable)
- [ ] No unauthenticated API calls to protected endpoints

### Error Handling Checklist
- [ ] 401 responses handled gracefully
- [ ] Redirect includes return URL
- [ ] Token retrieval errors handled
- [ ] Network errors handled

## Test Plan

**Objective**: Verify JWT tokens are sent with requests and auth errors handled

**Test Scope**: API client, authentication flow, error handling

**Manual Testing Steps**:

1. **Sign In and Make API Call**:
   - Sign in to app
   - Trigger API call (e.g., list environments)
   - Open DevTools Network tab
   - Verify Authorization header present
   - Verify request succeeds

2. **Check Token Format**:
   - Inspect Authorization header
   - Verify format: `Bearer <jwt_token>`
   - Verify token is valid JWT (check on jwt.io)

3. **Test 401 Redirect**:
   - Sign out (or expire token)
   - Try to access protected resource
   - Verify redirect to `/sign-in`
   - Verify return URL in query params

4. **Test Return URL Redirect**:
   - Get redirected to sign-in
   - Sign in
   - Verify redirected back to original page

5. **Test useCurrentUser Hook**:
   - Sign in
   - Check user data is loaded
   - Verify profile data displayed
   - Sign out
   - Verify query disabled when not signed in

**Success Criteria**:
- JWT tokens sent with all API requests
- 401 responses trigger sign-in redirect
- Return URL redirect works
- useCurrentUser hook works correctly

## Files Modified

âœ… **Completed:**
- `web/src/lib/api.ts` - Updated fetchJSON and fetchBlob with optional token parameter and 401 handling
- `web/src/lib/api/index.ts` - Updated fetchJSON with optional token parameter and 401 handling
- `web/src/hooks/useAuthenticatedFetch.ts` - Created authenticated fetch hook with Clerk's getToken()
- `web/src/hooks/useCurrentUser.ts` - Created hook to fetch Mirage user data from backend API
- `web/src/hooks/useRailway.ts` - Updated all query and mutation hooks to use authenticated fetch

**Implementation Details:**
- JWT tokens automatically retrieved from Clerk via `getToken()`
- Authorization header format: `Bearer <token>`
- 401 responses trigger automatic redirect to `/sign-in` with return URL
- All Railway API hooks now send authenticated requests
- useCurrentUser enables fetching Mirage database user record
- TypeScript compilation successful
- Production build successful (all routes compile correctly)

## Notes

### Clerk getToken()

**Token Retrieval**:
```typescript
const { getToken } = useAuth();
const token = await getToken();
// Returns JWT token for current session
// Returns null if not signed in
// Automatically refreshes if expired
```

**Token Caching**:
- Clerk caches tokens
- Automatically refreshes before expiration
- No manual refresh needed

### 401 vs 403 Handling

**401 Unauthorized**:
- Token missing, invalid, or expired
- Action: Redirect to sign-in
- User needs to re-authenticate

**403 Forbidden**:
- Authenticated but not authorized
- Action: Show error message
- Don't redirect (user is signed in)

### React Query Integration

**Query Options**:
```typescript
useQuery({
  queryKey: ['user', 'me'],
  queryFn: () => fetch('/api/v1/users/me'),
  enabled: isSignedIn, // Only run when signed in
  retry: (failureCount, error) => {
    // Don't retry 401 errors
    if (error.message.includes('401')) return false;
    return failureCount < 3;
  },
});
```

### Server-Side Rendering

**SSR Considerations**:
- getToken() works on server and client
- Clerk provides `auth()` for server components
- API calls from server need different approach

**Example (App Router)**:
```typescript
// In Server Component
import { auth } from '@clerk/nextjs';

export default async function Page() {
  const { getToken } = auth();
  const token = await getToken();
  
  // Make API call with token
}
```

### Alternative: Axios Interceptor

**If Using Axios** (not current setup):
```typescript
import axios from 'axios';

const apiClient = axios.create({
  baseURL: API_BASE_URL,
});

apiClient.interceptors.request.use(async (config) => {
  const token = await getToken();
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      window.location.href = '/sign-in';
    }
    return Promise.reject(error);
  }
);
```

### Testing Strategy

**Unit Tests**:
- Mock Clerk's useAuth hook
- Test fetchJSON with/without token
- Test 401 handling

**Integration Tests**:
- Real Clerk test environment
- Real API calls with authentication
- Test full auth flow

### Performance Considerations

**Token Caching**:
- Clerk caches tokens in memory
- No excessive token requests
- Refresh happens automatically

**Request Overhead**:
- JWT token adds ~1KB to each request
- Acceptable overhead for security
- Consider token size if adding custom claims

### Security Considerations

**Token Exposure**:
- JWT sent over HTTPS only in production
- Never log tokens
- Tokens have expiration (security)

**XSS Protection**:
- Clerk stores tokens securely
- Not in localStorage (XSS vulnerable)
- Stored in HTTP-only cookies or memory

### Integration Dependencies

**Requires**:
- Task 16-11: Clerk SDK installed
- Task 16-12: Sign-in page for redirects
- Task 16-5: Backend expects Authorization header

**Enables**:
- Task 16-14: User profile UI (uses useCurrentUser)
- Task 16-15: Protected routes
- Task 16-16: Wizard flows with auth

**Testing**:
- Task 16-20: E2E tests use authenticated requests


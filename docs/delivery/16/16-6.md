# [16-6] Implement Clerk webhook handler

[Back to task list](./tasks.md)

## Description

Create a webhook endpoint that receives Clerk events (user.created, user.updated, user.deleted) and synchronizes user data with the Mirage database. The handler must verify webhook signatures for security, implement idempotent processing to handle retries, and maintain user records in sync with Clerk's user management system.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-07 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |
| 2025-10-09 01:00:00 | Status Update | Proposed | InProgress | Started implementation | AI Agent |
| 2025-10-09 02:02:00 | Status Update | InProgress | Done | Task completed and approved | AI Agent |

## Requirements

1. **Webhook Endpoint**:
   - Route: `POST /api/webhooks/clerk`
   - Public endpoint (no authentication middleware)
   - Verify webhook signature using Clerk webhook secret
   - Parse webhook payload
   - Handle events: `user.created`, `user.updated`, `user.deleted`
   - Return appropriate HTTP status codes

2. **Signature Verification**:
   - Extract signature from `svix-signature` header
   - Verify using Clerk webhook secret
   - Reject webhooks with invalid signatures (401)
   - Use constant-time comparison to prevent timing attacks

3. **Event Handlers**:
   - **user.created**: Create new User record in database
   - **user.updated**: Update existing User record with new data
   - **user.deleted**: Set IsActive=false (soft delete)
   - All handlers must be idempotent

4. **Idempotency**:
   - Track processed webhook IDs to prevent duplicates
   - Use webhook ID from payload (`id` field)
   - Store processed IDs (in database or cache)
   - Skip already-processed webhooks

5. **Error Handling**:
   - 200 OK: Webhook processed successfully
   - 400 Bad Request: Invalid payload format
   - 401 Unauthorized: Invalid signature
   - 500 Internal Server Error: Database errors
   - Log all webhook events for debugging

6. **Data Mapping**:
   - Clerk `id` → `ClerkUserID`
   - Clerk `email_addresses[0].email_address` → `Email`
   - Clerk `first_name` → `FirstName`
   - Clerk `last_name` → `LastName`
   - Clerk `image_url` → `ProfileImageURL`

## Implementation Plan

### Phase 1: Create Webhook Package
Create `api/internal/webhooks/` package:
```
api/internal/webhooks/
├── clerk.go           - Main webhook handler
├── verification.go    - Signature verification
├── events.go          - Event type definitions
├── idempotency.go     - Webhook ID tracking
└── webhooks_test.go   - Unit tests
```

### Phase 2: Implement Signature Verification
In `api/internal/webhooks/verification.go`:
```go
package webhooks

import (
    "crypto/hmac"
    "crypto/sha256"
    "encoding/hex"
    "errors"
    "strings"
)

var (
    ErrInvalidSignature = errors.New("invalid webhook signature")
    ErrMissingSignature = errors.New("missing webhook signature header")
)

// VerifyWebhookSignature verifies the Clerk webhook signature
func VerifyWebhookSignature(payload []byte, signature string, secret string) error {
    if signature == "" {
        return ErrMissingSignature
    }
    
    // Clerk uses Svix for webhooks
    // Signature format: "v1,signature1 v1,signature2"
    // We need to check if any signature matches
    
    signatures := strings.Split(signature, " ")
    for _, sig := range signatures {
        parts := strings.SplitN(sig, ",", 2)
        if len(parts) != 2 || parts[0] != "v1" {
            continue
        }
        
        expectedSig := parts[1]
        if verifySignature(payload, expectedSig, secret) {
            return nil
        }
    }
    
    return ErrInvalidSignature
}

func verifySignature(payload []byte, signature string, secret string) bool {
    // Compute HMAC-SHA256
    mac := hmac.New(sha256.New, []byte(secret))
    mac.Write(payload)
    expectedMAC := mac.Sum(nil)
    expectedHex := hex.EncodeToString(expectedMAC)
    
    // Constant-time comparison
    return hmac.Equal([]byte(expectedHex), []byte(signature))
}
```

### Phase 3: Define Event Types
In `api/internal/webhooks/events.go`:
```go
package webhooks

type WebhookEvent struct {
    ID   string                 `json:"id"`
    Type string                 `json:"type"`
    Data map[string]interface{} `json:"data"`
}

type ClerkUser struct {
    ID             string   `json:"id"`
    FirstName      *string  `json:"first_name"`
    LastName       *string  `json:"last_name"`
    ImageURL       *string  `json:"image_url"`
    EmailAddresses []struct {
        EmailAddress string `json:"email_address"`
        ID           string `json:"id"`
    } `json:"email_addresses"`
}

// ExtractUser extracts user data from webhook payload
func ExtractUser(data map[string]interface{}) (*ClerkUser, error) {
    jsonData, err := json.Marshal(data)
    if err != nil {
        return nil, err
    }
    
    var user ClerkUser
    if err := json.Unmarshal(jsonData, &user); err != nil {
        return nil, err
    }
    
    return &user, nil
}
```

### Phase 4: Implement Idempotency Tracking
In `api/internal/webhooks/idempotency.go`:
```go
package webhooks

import (
    "sync"
    "time"
)

// WebhookIDCache tracks processed webhook IDs to prevent duplicates
type WebhookIDCache struct {
    mu      sync.RWMutex
    ids     map[string]time.Time
    ttl     time.Duration
}

func NewWebhookIDCache(ttl time.Duration) *WebhookIDCache {
    cache := &WebhookIDCache{
        ids: make(map[string]time.Time),
        ttl: ttl,
    }
    
    // Cleanup expired entries periodically
    go cache.cleanup()
    
    return cache
}

// MarkProcessed marks a webhook ID as processed
func (c *WebhookIDCache) MarkProcessed(id string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.ids[id] = time.Now().Add(c.ttl)
}

// IsProcessed checks if a webhook ID has been processed
func (c *WebhookIDCache) IsProcessed(id string) bool {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    expiry, exists := c.ids[id]
    if !exists {
        return false
    }
    
    // Check if expired
    return time.Now().Before(expiry)
}

func (c *WebhookIDCache) cleanup() {
    ticker := time.NewTicker(1 * time.Hour)
    defer ticker.Stop()
    
    for range ticker.C {
        c.mu.Lock()
        now := time.Now()
        for id, expiry := range c.ids {
            if now.After(expiry) {
                delete(c.ids, id)
            }
        }
        c.mu.Unlock()
    }
}
```

### Phase 5: Implement Webhook Handler
In `api/internal/webhooks/clerk.go`:
```go
package webhooks

import (
    "encoding/json"
    "io"
    "net/http"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/google/uuid"
    "github.com/rs/zerolog/log"
    "github.com/stwalsh4118/mirageapi/internal/store"
    "gorm.io/gorm"
)

const (
    EventUserCreated = "user.created"
    EventUserUpdated = "user.updated"
    EventUserDeleted = "user.deleted"
)

type ClerkWebhookHandler struct {
    DB            *gorm.DB
    WebhookSecret string
    IDCache       *WebhookIDCache
}

func NewClerkWebhookHandler(db *gorm.DB, secret string) *ClerkWebhookHandler {
    return &ClerkWebhookHandler{
        DB:            db,
        WebhookSecret: secret,
        IDCache:       NewWebhookIDCache(24 * time.Hour),
    }
}

func (h *ClerkWebhookHandler) HandleWebhook(c *gin.Context) {
    // Read raw body for signature verification
    body, err := io.ReadAll(c.Request.Body)
    if err != nil {
        log.Error().Err(err).Msg("failed to read webhook body")
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
        return
    }
    
    // Verify signature
    signature := c.GetHeader("svix-signature")
    if err := VerifyWebhookSignature(body, signature, h.WebhookSecret); err != nil {
        log.Warn().Err(err).Msg("webhook signature verification failed")
        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid signature"})
        return
    }
    
    // Parse webhook payload
    var event WebhookEvent
    if err := json.Unmarshal(body, &event); err != nil {
        log.Error().Err(err).Msg("failed to parse webhook payload")
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid payload"})
        return
    }
    
    // Check idempotency
    if h.IDCache.IsProcessed(event.ID) {
        log.Info().Str("webhook_id", event.ID).Msg("webhook already processed, skipping")
        c.Status(http.StatusOK)
        return
    }
    
    // Route to event handler
    switch event.Type {
    case EventUserCreated:
        err = h.handleUserCreated(event.Data)
    case EventUserUpdated:
        err = h.handleUserUpdated(event.Data)
    case EventUserDeleted:
        err = h.handleUserDeleted(event.Data)
    default:
        log.Info().Str("event_type", event.Type).Msg("unhandled webhook event type")
        c.Status(http.StatusOK)
        return
    }
    
    if err != nil {
        log.Error().Err(err).Str("event_type", event.Type).Msg("failed to process webhook")
        c.JSON(http.StatusInternalServerError, gin.H{"error": "processing failed"})
        return
    }
    
    // Mark as processed
    h.IDCache.MarkProcessed(event.ID)
    
    log.Info().
        Str("webhook_id", event.ID).
        Str("event_type", event.Type).
        Msg("webhook processed successfully")
    
    c.Status(http.StatusOK)
}

func (h *ClerkWebhookHandler) handleUserCreated(data map[string]interface{}) error {
    clerkUser, err := ExtractUser(data)
    if err != nil {
        return err
    }
    
    // Get primary email
    var email string
    if len(clerkUser.EmailAddresses) > 0 {
        email = clerkUser.EmailAddresses[0].EmailAddress
    }
    
    user := store.User{
        ID:              uuid.New().String(),
        ClerkUserID:     clerkUser.ID,
        Email:           email,
        FirstName:       clerkUser.FirstName,
        LastName:        clerkUser.LastName,
        ProfileImageURL: clerkUser.ImageURL,
        IsActive:        true,
        CreatedAt:       time.Now(),
        UpdatedAt:       time.Now(),
    }
    
    // Upsert to handle race conditions
    err = h.DB.Where("clerk_user_id = ?", user.ClerkUserID).
        Assign(user).
        FirstOrCreate(&user).Error
    
    if err != nil {
        return err
    }
    
    log.Info().
        Str("user_id", user.ID).
        Str("clerk_user_id", user.ClerkUserID).
        Str("email", user.Email).
        Msg("user created")
    
    return nil
}

func (h *ClerkWebhookHandler) handleUserUpdated(data map[string]interface{}) error {
    clerkUser, err := ExtractUser(data)
    if err != nil {
        return err
    }
    
    // Find existing user
    var user store.User
    err = h.DB.Where("clerk_user_id = ?", clerkUser.ID).First(&user).Error
    if err != nil {
        return err
    }
    
    // Update fields
    updates := map[string]interface{}{
        "first_name":        clerkUser.FirstName,
        "last_name":         clerkUser.LastName,
        "profile_image_url": clerkUser.ImageURL,
        "updated_at":        time.Now(),
    }
    
    // Update email if changed
    if len(clerkUser.EmailAddresses) > 0 {
        updates["email"] = clerkUser.EmailAddresses[0].EmailAddress
    }
    
    err = h.DB.Model(&user).Updates(updates).Error
    if err != nil {
        return err
    }
    
    log.Info().
        Str("user_id", user.ID).
        Str("clerk_user_id", user.ClerkUserID).
        Msg("user updated")
    
    return nil
}

func (h *ClerkWebhookHandler) handleUserDeleted(data map[string]interface{}) error {
    clerkUserID, ok := data["id"].(string)
    if !ok {
        return errors.New("missing user id in delete event")
    }
    
    // Soft delete: set IsActive=false
    err := h.DB.Model(&store.User{}).
        Where("clerk_user_id = ?", clerkUserID).
        Updates(map[string]interface{}{
            "is_active":  false,
            "updated_at": time.Now(),
        }).Error
    
    if err != nil {
        return err
    }
    
    log.Info().
        Str("clerk_user_id", clerkUserID).
        Msg("user marked inactive")
    
    return nil
}
```

### Phase 6: Register Webhook Route
Update `api/internal/server/server.go`:
```go
import (
    "github.com/stwalsh4118/mirageapi/internal/webhooks"
)

func NewHTTPServer(cfg config.AppConfig, deps ...any) *gin.Engine {
    // ... existing setup ...
    
    // Webhook endpoints (no auth middleware)
    if db != nil && cfg.ClerkWebhookSecret != "" {
        webhookHandler := webhooks.NewClerkWebhookHandler(db, cfg.ClerkWebhookSecret)
        api.POST("/webhooks/clerk", webhookHandler.HandleWebhook)
    }
    
    // ... rest of routes ...
}
```

## Verification

### Implementation Checklist
- [ ] Webhook package created with all files
- [ ] Signature verification implemented
- [ ] Event type definitions created
- [ ] Idempotency cache implemented
- [ ] User created handler implemented
- [ ] User updated handler implemented
- [ ] User deleted handler implemented
- [ ] Webhook route registered (no auth)
- [ ] Configuration updated with webhook secret
- [ ] Logging added for all events

### Security Checklist
- [ ] Signature verification uses constant-time comparison
- [ ] Invalid signatures return 401
- [ ] Webhook secret loaded from environment
- [ ] No sensitive data logged
- [ ] Rate limiting considered (future enhancement)

### Idempotency Checklist
- [ ] Webhook IDs tracked
- [ ] Duplicate webhooks skipped
- [ ] Cache cleanup implemented
- [ ] TTL configured (24 hours)

## Test Plan

**Objective**: Verify webhook handler correctly processes Clerk events

**Test Scope**: Signature verification, event handlers, idempotency

**Mocking Strategy**:
- Mock webhook payloads from Clerk documentation
- Generate valid signatures for testing
- Use in-memory database for tests

**Key Test Scenarios**:

1. **Valid user.created Event**
   - Given: Valid webhook with user.created event
   - When: Webhook received
   - Then: User record created in database

2. **Valid user.updated Event**
   - Given: Existing user, valid webhook with user.updated event
   - When: Webhook received
   - Then: User record updated with new data

3. **Valid user.deleted Event**
   - Given: Existing active user, valid webhook with user.deleted event
   - When: Webhook received
   - Then: User.IsActive set to false

4. **Invalid Signature**
   - Given: Webhook with invalid signature
   - When: Webhook received
   - Then: 401 response, event not processed

5. **Missing Signature**
   - Given: Webhook without signature header
   - When: Webhook received
   - Then: 401 response, event not processed

6. **Duplicate Webhook**
   - Given: Webhook already processed (same ID)
   - When: Webhook received again
   - Then: 200 response, skipped, no database changes

7. **Invalid Payload Format**
   - Given: Malformed JSON payload
   - When: Webhook received
   - Then: 400 response

8. **Unknown Event Type**
   - Given: Valid webhook with unknown event type
   - When: Webhook received
   - Then: 200 response, event ignored

9. **Database Error During Create**
   - Given: Database unavailable
   - When: user.created webhook received
   - Then: 500 response, error logged

10. **Race Condition - Duplicate Create**
    - Given: Two user.created webhooks for same user (network retry)
    - When: Both webhooks processed
    - Then: Only one user created (upsert handles collision)

**Success Criteria**:
- All test scenarios pass
- Signature verification works correctly
- Event handlers create/update/delete users
- Idempotency prevents duplicates
- Error handling returns correct status codes

## Files Modified

- `api/internal/webhooks/clerk.go` - Main webhook handler
- `api/internal/webhooks/verification.go` - Signature verification
- `api/internal/webhooks/events.go` - Event type definitions
- `api/internal/webhooks/idempotency.go` - Webhook ID cache
- `api/internal/webhooks/webhooks_test.go` - Unit tests
- `api/internal/config/config.go` - Add ClerkWebhookSecret field
- `api/internal/server/server.go` - Register webhook route
- `.env.example` - Add CLERK_WEBHOOK_SECRET

## Notes

### Clerk Webhook Format

**Signature Headers**:
- `svix-id`: Webhook message ID
- `svix-timestamp`: Unix timestamp
- `svix-signature`: HMAC signature (v1,sig1 v1,sig2 format)

**Payload Structure**:
```json
{
  "data": {
    "id": "user_2abc...",
    "email_addresses": [
      {"email_address": "user@example.com", "id": "email_123"}
    ],
    "first_name": "John",
    "last_name": "Doe",
    "image_url": "https://...",
    "created_at": 1234567890,
    "updated_at": 1234567891
  },
  "object": "event",
  "type": "user.created"
}
```

### Idempotency Strategy

**Why In-Memory Cache**:
- Webhook retries happen within hours
- 24-hour TTL is sufficient
- Avoids database overhead
- Alternative: Store in database if persistence needed

**Webhook ID Format**:
- Clerk generates unique ID per webhook
- Format: `msg_...` (Svix message ID)
- Guaranteed unique across all events

### Error Handling Philosophy

**Return 200 Even for Skipped Events**:
- Prevents Clerk from retrying
- Already processed webhooks return success
- Unknown event types return success
- Only return 4xx/5xx for actual errors

**When to Return Errors**:
- 400: Malformed payload (Clerk bug, unlikely)
- 401: Invalid signature (security issue)
- 500: Database errors (temporary, should retry)

### Race Conditions

**Duplicate user.created**:
- Use `FirstOrCreate` with `Where` clause
- Upsert pattern handles race
- Last write wins for updates

**Webhook Ordering**:
- Webhooks may arrive out of order
- Use timestamp fields if ordering matters
- For user data, latest update is fine

### Testing with Clerk Dashboard

**Manual Testing**:
1. Go to Webhooks section
2. Click "Testing" tab
3. Select event type
4. Send test webhook
5. View delivery logs

**Webhook Logs**:
- Shows delivery attempts
- Response status codes
- Response body
- Timing information

### Production Considerations

**Webhook Endpoint Requirements**:
- Must be HTTPS in production
- Must respond within 15 seconds
- Should return 200 for success
- Clerk retries on 4xx/5xx errors

**Monitoring**:
- Log all webhook events
- Alert on high failure rates
- Track webhook processing time
- Monitor idempotency cache size

**Scalability**:
- Webhook handler should be fast
- Offload heavy processing to background jobs
- Current implementation is suitable for MVP
- Consider queue-based processing for high volume

### Alternative Implementations

**Database-Based Idempotency**:
```go
// Store processed webhook IDs in database
type ProcessedWebhook struct {
    ID string `gorm:"primaryKey"`
    ProcessedAt time.Time
}

// Check before processing
var count int64
db.Model(&ProcessedWebhook{}).Where("id = ?", webhookID).Count(&count)
if count > 0 {
    // Already processed
}
```

**Queue-Based Processing**:
- Webhook handler pushes event to queue
- Background worker processes events
- Better for high-volume scenarios
- Not needed for MVP

### Integration Dependencies

**Requires**:
- Task 16-2: Webhook secret from Clerk setup
- Task 16-3: User model must exist

**Enables**:
- Task 16-5: Middleware can load users created by webhooks
- Task 16-7/16-8: Controllers can reference users

**Testing**:
- Task 16-18: Integration tests for webhook flow


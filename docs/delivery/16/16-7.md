# [16-7] Update Environment controller with ownership checks

[Back to task list](./tasks.md)

## Description

Update the EnvironmentController to enforce resource ownership by automatically assigning UserID to new environments, filtering all queries by authenticated user, and implementing 403 Forbidden responses when users attempt to access other users' resources. This ensures complete resource isolation between users.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-07 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |

## Requirements

1. **Create Operations**:
   - Extract UserID from authenticated request context
   - Automatically set UserID when creating Environment records
   - Automatically set UserID when creating EnvironmentMetadata records
   - Remove any UserID fields from request payloads (security)

2. **Read Operations**:
   - Filter all list queries by `user_id = ?`
   - Add ownership check to all get-by-id operations
   - Return 403 Forbidden if user tries to access another user's environment
   - Return 404 if environment doesn't exist or doesn't belong to user

3. **Update Operations**:
   - Verify ownership before allowing updates
   - Return 403 if user doesn't own the resource
   - Never allow changing UserID of existing resources

4. **Delete Operations**:
   - Verify ownership before allowing deletes
   - Return 403 if user doesn't own the resource
   - Cascade to owned services and metadata

5. **Railway Proxy Endpoints**:
   - List Railway projects: No filtering needed (Railway-level resources)
   - Get/Delete Railway project: Verify at least one environment owned by user
   - Delete Railway environment: Verify corresponding Mirage environment ownership

6. **Template Endpoints**:
   - ListTemplates: Filter by UserID
   - Only show templates created by authenticated user

## Implementation Plan

### Phase 1: Update ProvisionEnvironment
In `api/internal/controller/environment.go`:

```go
func (c *EnvironmentController) ProvisionEnvironment(ctx *gin.Context) {
    if c.Railway == nil {
        ctx.JSON(http.StatusServiceUnavailable, gin.H{"error": "railway client not configured"})
        return
    }
    
    // Get authenticated user
    user, err := auth.GetCurrentUser(ctx)
    if err != nil {
        ctx.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
        return
    }
    
    var req ProvisionEnvironmentRequest
    if err := ctx.ShouldBindJSON(&req); err != nil {
        ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // Create environment in Railway
    res, err := c.Railway.CreateEnvironment(ctx, railway.CreateEnvironmentInput{
        ProjectID: req.ProjectID,
        Name:      req.Name,
    })
    if err != nil {
        ctx.JSON(http.StatusBadGateway, gin.H{"error": err.Error()})
        return
    }
    
    // Persist with UserID from authenticated context
    if c.DB != nil {
        envType := store.EnvironmentTypeDev
        if req.EnvType != nil {
            envType = *req.EnvType
        }
        
        env := store.Environment{
            ID:                   uuid.New().String(),
            UserID:               user.ID,  // ← Set from authenticated user
            Name:                 req.Name,
            Type:                 envType,
            Status:               status.StatusCreating,
            RailwayProjectID:     req.ProjectID,
            RailwayEnvironmentID: res.EnvironmentID,
            CreatedAt:            time.Now(),
            UpdatedAt:            time.Now(),
        }
        
        txErr := c.DB.Transaction(func(tx *gorm.DB) error {
            if err := tx.Create(&env).Error; err != nil {
                return err
            }
            
            // Create metadata with UserID
            if len(req.WizardInputs) > 0 {
                metadata := store.EnvironmentMetadata{
                    ID:                   uuid.New().String(),
                    UserID:               user.ID,  // ← Set from authenticated user
                    EnvironmentID:        env.ID,
                    WizardInputsJSON:     ...,
                    ProvisionOutputsJSON: ...,
                    CreatedAt:            time.Now(),
                    UpdatedAt:            time.Now(),
                }
                
                if err := tx.Create(&metadata).Error; err != nil {
                    return err
                }
            }
            
            return nil
        })
        
        // ... error handling ...
    }
    
    ctx.JSON(http.StatusOK, ProvisionEnvironmentResponse{
        EnvironmentID:        env.ID,
        RailwayEnvironmentID: res.EnvironmentID,
    })
}
```

### Phase 2: Update GetEnvironmentMetadata
```go
func (c *EnvironmentController) GetEnvironmentMetadata(ctx *gin.Context) {
    railwayEnvID := ctx.Param("id")
    if railwayEnvID == "" {
        ctx.JSON(http.StatusBadRequest, gin.H{"error": "railway environment id required"})
        return
    }
    
    // Get authenticated user
    user, err := auth.GetCurrentUser(ctx)
    if err != nil {
        ctx.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
        return
    }
    
    // Look up environment with ownership check
    var env store.Environment
    err = c.DB.Where("railway_environment_id = ? AND user_id = ?", railwayEnvID, user.ID).
        First(&env).Error
    
    if err == gorm.ErrRecordNotFound {
        ctx.JSON(http.StatusNotFound, gin.H{"error": "environment not found"})
        return
    } else if err != nil {
        log.Error().Err(err).Msg("failed to query environment")
        ctx.JSON(http.StatusInternalServerError, gin.H{"error": "failed to retrieve environment"})
        return
    }
    
    // Look up metadata with ownership check
    var metadata store.EnvironmentMetadata
    err = c.DB.Where("environment_id = ? AND user_id = ?", env.ID, user.ID).
        First(&metadata).Error
    
    // ... rest of handler ...
}
```

### Phase 3: Update ListEnvironmentServices
```go
func (c *EnvironmentController) ListEnvironmentServices(ctx *gin.Context) {
    railwayEnvID := ctx.Param("id")
    if railwayEnvID == "" {
        ctx.JSON(http.StatusBadRequest, gin.H{"error": "railway environment id required"})
        return
    }
    
    // Get authenticated user
    user, err := auth.GetCurrentUser(ctx)
    if err != nil {
        ctx.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
        return
    }
    
    // Look up environment with ownership check
    var env store.Environment
    err = c.DB.Where("railway_environment_id = ? AND user_id = ?", railwayEnvID, user.ID).
        First(&env).Error
    
    if err == gorm.ErrRecordNotFound {
        ctx.JSON(http.StatusNotFound, gin.H{"error": "environment not found"})
        return
    } else if err != nil {
        log.Error().Err(err).Msg("failed to query environment")
        ctx.JSON(http.StatusInternalServerError, gin.H{"error": "failed to retrieve environment"})
        return
    }
    
    // Query services (already filtered by environment ownership)
    var services []store.Service
    err = c.DB.Where("environment_id = ?", env.ID).Find(&services).Error
    
    // ... rest of handler ...
}
```

### Phase 4: Update ListTemplates
```go
func (c *EnvironmentController) ListTemplates(ctx *gin.Context) {
    // Get authenticated user
    user, err := auth.GetCurrentUser(ctx)
    if err != nil {
        ctx.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
        return
    }
    
    // Filter templates by user
    var metadataList []store.EnvironmentMetadata
    err = c.DB.Where("is_template = ? AND user_id = ?", true, user.ID).
        Find(&metadataList).Error
    
    if err != nil {
        log.Error().Err(err).Msg("failed to query templates")
        ctx.JSON(http.StatusInternalServerError, gin.H{"error": "failed to retrieve templates"})
        return
    }
    
    // ... rest of handler ...
}
```

### Phase 5: Update GetEnvironmentSnapshot
```go
func (c *EnvironmentController) GetEnvironmentSnapshot(ctx *gin.Context) {
    railwayEnvID := ctx.Param("id")
    if railwayEnvID == "" {
        ctx.JSON(http.StatusBadRequest, gin.H{"error": "railway environment id required"})
        return
    }
    
    // Get authenticated user
    user, err := auth.GetCurrentUser(ctx)
    if err != nil {
        ctx.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
        return
    }
    
    // Look up environment with ownership check
    var env store.Environment
    err = c.DB.Preload("Services").
        Where("railway_environment_id = ? AND user_id = ?", railwayEnvID, user.ID).
        First(&env).Error
    
    if err == gorm.ErrRecordNotFound {
        ctx.JSON(http.StatusNotFound, gin.H{"error": "environment not found"})
        return
    } else if err != nil {
        log.Error().Err(err).Msg("failed to query environment")
        ctx.JSON(http.StatusInternalServerError, gin.H{"error": "failed to retrieve environment"})
        return
    }
    
    // ... rest of handler ...
}
```

### Phase 6: Update Railway Delete Operations
```go
func (c *EnvironmentController) DeleteRailwayEnvironment(ctx *gin.Context) {
    if c.Railway == nil {
        ctx.JSON(http.StatusServiceUnavailable, gin.H{"error": "railway client not configured"})
        return
    }
    
    railwayEnvID := ctx.Param("id")
    if railwayEnvID == "" {
        ctx.JSON(http.StatusBadRequest, gin.H{"error": "environment id required"})
        return
    }
    
    // Get authenticated user
    user, err := auth.GetCurrentUser(ctx)
    if err != nil {
        ctx.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
        return
    }
    
    // Verify ownership before deleting
    var env store.Environment
    err = c.DB.Where("railway_environment_id = ? AND user_id = ?", railwayEnvID, user.ID).
        First(&env).Error
    
    if err == gorm.ErrRecordNotFound {
        ctx.JSON(http.StatusForbidden, gin.H{"error": "environment not found or access denied"})
        return
    } else if err != nil {
        log.Error().Err(err).Msg("failed to query environment")
        ctx.JSON(http.StatusInternalServerError, gin.H{"error": "failed to verify ownership"})
        return
    }
    
    // Delete from Railway
    err = c.Railway.DestroyEnvironment(ctx, railway.DestroyEnvironmentInput{
        EnvironmentID: railwayEnvID,
    })
    
    if err != nil {
        log.Error().Err(err).Msg("railway delete environment failed")
        ctx.JSON(http.StatusBadGateway, gin.H{"error": err.Error()})
        return
    }
    
    // Delete from database
    if c.DB != nil {
        c.DB.Where("railway_environment_id = ?", railwayEnvID).Delete(&store.Environment{})
    }
    
    ctx.Status(http.StatusNoContent)
}
```

### Phase 7: Add Ownership Helper Function
Create helper for ownership verification:
```go
// verifyEnvironmentOwnership checks if the authenticated user owns the environment
func (c *EnvironmentController) verifyEnvironmentOwnership(ctx *gin.Context, railwayEnvID string) (*store.Environment, error) {
    user, err := auth.GetCurrentUser(ctx)
    if err != nil {
        return nil, err
    }
    
    var env store.Environment
    err = c.DB.Where("railway_environment_id = ? AND user_id = ?", railwayEnvID, user.ID).
        First(&env).Error
    
    return &env, err
}
```

## Verification

### Implementation Checklist
- [ ] ProvisionEnvironment sets UserID from auth context
- [ ] EnvironmentMetadata sets UserID from auth context
- [ ] GetEnvironmentMetadata filters by user
- [ ] ListEnvironmentServices verifies ownership
- [ ] GetEnvironmentSnapshot verifies ownership
- [ ] ListTemplates filters by user
- [ ] DeleteRailwayEnvironment verifies ownership
- [ ] DeleteRailwayProject verifies at least one owned environment
- [ ] All queries include `user_id = ?` filter
- [ ] Ownership helper function created

### Security Checklist
- [ ] Cannot create environment for another user
- [ ] Cannot view another user's environments
- [ ] Cannot update another user's environments
- [ ] Cannot delete another user's environments
- [ ] 403 responses for unauthorized access
- [ ] 404 responses when resource doesn't exist or not owned

### Error Handling Checklist
- [ ] 401 when authentication fails
- [ ] 403 when ownership check fails
- [ ] 404 when resource not found
- [ ] Clear error messages
- [ ] Appropriate logging

## Test Plan

**Objective**: Verify environment ownership is enforced for all operations

**Test Scope**: Environment controller endpoints with authentication

**Environment & Setup**:
- Two test users (user1, user2)
- Test environments created by each user
- Authenticated requests with valid JWT tokens

**Key Test Scenarios**:

1. **Create Environment with Auth**
   - Given: User authenticated
   - When: POST /provision/environment
   - Then: Environment created with UserID set to authenticated user

2. **List User's Own Environments**
   - Given: User1 has 2 environments, User2 has 3 environments
   - When: User1 queries their environments
   - Then: Only User1's 2 environments returned

3. **Get Another User's Environment Metadata**
   - Given: Environment belongs to User2
   - When: User1 tries to get metadata
   - Then: 404 response (not 403 to avoid info disclosure)

4. **List Services for Own Environment**
   - Given: User1 owns environment
   - When: User1 lists services
   - Then: Services returned

5. **List Services for Another User's Environment**
   - Given: Environment belongs to User2
   - When: User1 tries to list services
   - Then: 404 response

6. **Delete Own Environment**
   - Given: User1 owns environment
   - When: User1 deletes environment
   - Then: Environment deleted successfully

7. **Delete Another User's Environment**
   - Given: Environment belongs to User2
   - When: User1 tries to delete
   - Then: 403 Forbidden response

8. **List Templates Filtered by User**
   - Given: User1 has 1 template, User2 has 2 templates
   - When: User1 lists templates
   - Then: Only User1's template returned

9. **Get Snapshot for Own Environment**
   - Given: User1 owns environment
   - When: User1 gets snapshot
   - Then: Full snapshot returned

10. **Get Snapshot for Another User's Environment**
    - Given: Environment belongs to User2
    - When: User1 tries to get snapshot
    - Then: 404 response

**Success Criteria**:
- All ownership checks pass
- Users can only access their own resources
- Appropriate error codes returned
- No information leakage about other users' resources

## Files Modified

- `api/internal/controller/environment.go` - Add ownership checks to all methods
- `api/internal/controller/environment_test.go` - Update tests with multiple users

## Notes

### Security Considerations

**Information Disclosure**:
- Return 404 instead of 403 for non-owned resources
- Prevents attackers from enumerating valid resource IDs
- 403 reveals "resource exists but you can't access it"
- 404 reveals nothing about existence

**UserID in Requests**:
- Never accept UserID from request payload
- Always get from authenticated context
- Prevents user impersonation attacks

**Railway Resource Ownership**:
- Railway projects are not user-scoped (shared infra)
- Only check ownership of Mirage environments
- Delete Railway resources only if user owns corresponding Mirage resource

### Performance Considerations

**Query Optimization**:
- All ownership queries use indexed columns (user_id)
- Combined filters: `WHERE railway_environment_id = ? AND user_id = ?`
- Both columns indexed for optimal performance

**N+1 Query Prevention**:
- Use `Preload` for relationships when needed
- Example: `Preload("Services")` when fetching environment with services

### Error Response Patterns

**401 Unauthorized**:
- Authentication failed or missing
- User should re-authenticate

**403 Forbidden**:
- Authenticated but not authorized
- Use sparingly (info disclosure risk)
- OK for delete operations (already revealed existence)

**404 Not Found**:
- Resource doesn't exist OR user doesn't own it
- Ambiguous by design (security)
- Consistent with REST best practices

### Testing Strategy

**Unit Tests**:
- Mock authenticated user context
- Test each controller method in isolation
- Verify ownership checks with multiple users

**Integration Tests** (task 16-19):
- Real database with multiple users
- Full request/response cycle
- Test cross-user access attempts

### Alternative Approaches Considered

**Middleware-Level Filtering**:
- Could create middleware that auto-filters all queries
- Con: Less explicit, harder to debug
- Con: Doesn't work for Railway operations
- Decision: Controller-level checks are clearer

**Database-Level Row Security**:
- PostgreSQL RLS (Row-Level Security)
- Con: Doesn't work with SQLite
- Con: Adds complexity
- Decision: Application-level checks for portability

### Integration Dependencies

**Requires**:
- Task 16-4: UserID column in Environment model
- Task 16-5: RequireAuth middleware and context helpers
- Task 16-6: Users created via webhooks

**Integrates With**:
- Task 16-8: Services controller (similar patterns)
- Task 16-10: Middleware applied to these routes

**Testing**:
- Task 16-19: Integration tests for ownership


# [16-5] Implement Clerk JWT verification middleware

[Back to task list](./tasks.md)

## Description

Create authentication middleware for Gin that verifies Clerk JWT tokens from the Authorization header, extracts the Clerk user ID, loads the corresponding User from the database, and adds it to the request context. This middleware is the core of the authentication system and will be applied to all protected routes.

This task implements the patterns researched in task 16-1.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-07 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |

## Requirements

1. **Middleware Function**:
   - Name: `RequireAuth()` - returns `gin.HandlerFunc`
   - Extract JWT from `Authorization: Bearer <token>` header
   - Verify JWT using Clerk SDK
   - Extract Clerk user ID from verified token claims
   - Load User from database by ClerkUserID
   - Add User to Gin context for downstream handlers
   - Return appropriate error responses (401, 404, 500)

2. **Context Helpers**:
   - `GetCurrentUser(c *gin.Context) (*store.User, error)` - Type-safe user retrieval
   - `GetCurrentUserID(c *gin.Context) (string, error)` - Just get the user ID
   - Both should return errors if user not in context

3. **LastSeenAt Tracking**:
   - Update user's LastSeenAt timestamp (throttled to once per hour max)
   - Async update to avoid blocking request
   - Error in update shouldn't fail request

4. **Configuration**:
   - Clerk secret key from environment variable `CLERK_SECRET_KEY`
   - Clerk client initialized once and reused

5. **Error Handling**:
   - 401 Unauthorized: Missing token, invalid token, expired token
   - 404 Not Found: Token valid but user not in database (webhook lag)
   - 500 Internal Server Error: Database errors, SDK errors
   - Error responses include clear messages for debugging

## Implementation Plan

### Phase 1: Create Auth Package Structure
Create `api/internal/auth/` package:
```
api/internal/auth/
├── middleware.go  - RequireAuth middleware
├── context.go     - Context helper functions
├── clerk.go       - Clerk client initialization
└── auth_test.go   - Unit tests
```

### Phase 2: Initialize Clerk Client
In `api/internal/auth/clerk.go`:
```go
package auth

import (
    "sync"
    "github.com/clerk/clerk-sdk-go/v2"
)

var (
    clerkClient *clerk.Client
    initOnce    sync.Once
)

// InitClerkClient initializes the Clerk SDK client (call once at startup)
func InitClerkClient(secretKey string) error {
    var err error
    initOnce.Do(func() {
        clerkClient, err = clerk.NewClient(secretKey)
    })
    return err
}

// GetClerkClient returns the initialized Clerk client
func GetClerkClient() *clerk.Client {
    return clerkClient
}
```

### Phase 3: Implement JWT Verification Middleware
In `api/internal/auth/middleware.go`:
```go
package auth

import (
    "net/http"
    "strings"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/rs/zerolog/log"
    "github.com/stwalsh4118/mirageapi/internal/store"
    "gorm.io/gorm"
)

const (
    contextKeyUser = "auth:user"
    lastSeenThrottleHours = 1
)

// RequireAuth is middleware that verifies Clerk JWT and loads user
func RequireAuth(db *gorm.DB) gin.HandlerFunc {
    return func(c *gin.Context) {
        // Extract token from Authorization header
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": "missing authorization header",
            })
            c.Abort()
            return
        }
        
        // Parse "Bearer <token>"
        parts := strings.SplitN(authHeader, " ", 2)
        if len(parts) != 2 || parts[0] != "Bearer" {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": "invalid authorization header format, expected 'Bearer <token>'",
            })
            c.Abort()
            return
        }
        token := parts[1]
        
        // Verify JWT with Clerk SDK
        claims, err := GetClerkClient().VerifyToken(token)
        if err != nil {
            log.Debug().Err(err).Msg("jwt verification failed")
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": "invalid or expired token",
            })
            c.Abort()
            return
        }
        
        // Extract Clerk user ID from claims
        clerkUserID, ok := claims["sub"].(string)
        if !ok || clerkUserID == "" {
            log.Error().Msg("jwt claims missing 'sub' field")
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": "invalid token claims",
            })
            c.Abort()
            return
        }
        
        // Load user from database
        var user store.User
        err = db.Where("clerk_user_id = ?", clerkUserID).First(&user).Error
        if err == gorm.ErrRecordNotFound {
            log.Warn().
                Str("clerk_user_id", clerkUserID).
                Msg("user not found in database (webhook may not have processed yet)")
            c.JSON(http.StatusNotFound, gin.H{
                "error": "user not found - please try again in a moment",
            })
            c.Abort()
            return
        } else if err != nil {
            log.Error().Err(err).Str("clerk_user_id", clerkUserID).Msg("failed to load user")
            c.JSON(http.StatusInternalServerError, gin.H{
                "error": "failed to load user",
            })
            c.Abort()
            return
        }
        
        // Check if user is active
        if !user.IsActive {
            log.Warn().Str("user_id", user.ID).Msg("inactive user attempted access")
            c.JSON(http.StatusForbidden, gin.H{
                "error": "user account is inactive",
            })
            c.Abort()
            return
        }
        
        // Update LastSeenAt if needed (async, throttled)
        go updateLastSeenAt(db, &user)
        
        // Store user in context
        c.Set(contextKeyUser, &user)
        
        log.Debug().
            Str("user_id", user.ID).
            Str("email", user.Email).
            Msg("request authenticated")
        
        c.Next()
    }
}

// updateLastSeenAt updates user's LastSeenAt timestamp if last update was > 1 hour ago
func updateLastSeenAt(db *gorm.DB, user *store.User) {
    now := time.Now()
    
    // Throttle: only update if last seen was > 1 hour ago or never set
    if user.LastSeenAt != nil {
        elapsed := now.Sub(*user.LastSeenAt)
        if elapsed < lastSeenThrottleHours*time.Hour {
            return
        }
    }
    
    // Update in background (don't block request)
    err := db.Model(&store.User{}).
        Where("id = ?", user.ID).
        Update("last_seen_at", now).
        Error
    
    if err != nil {
        log.Warn().Err(err).Str("user_id", user.ID).Msg("failed to update last_seen_at")
    }
}
```

### Phase 4: Implement Context Helpers
In `api/internal/auth/context.go`:
```go
package auth

import (
    "errors"
    
    "github.com/gin-gonic/gin"
    "github.com/stwalsh4118/mirageapi/internal/store"
)

var (
    ErrUserNotInContext = errors.New("user not found in request context")
)

// GetCurrentUser retrieves the authenticated user from the request context
func GetCurrentUser(c *gin.Context) (*store.User, error) {
    val, exists := c.Get(contextKeyUser)
    if !exists {
        return nil, ErrUserNotInContext
    }
    
    user, ok := val.(*store.User)
    if !ok {
        return nil, errors.New("invalid user type in context")
    }
    
    return user, nil
}

// GetCurrentUserID retrieves just the user ID from the request context
func GetCurrentUserID(c *gin.Context) (string, error) {
    user, err := GetCurrentUser(c)
    if err != nil {
        return "", err
    }
    return user.ID, nil
}

// MustGetCurrentUser retrieves the user or panics (use only when user is guaranteed)
func MustGetCurrentUser(c *gin.Context) *store.User {
    user, err := GetCurrentUser(c)
    if err != nil {
        panic("user not in context - did you forget to apply RequireAuth middleware?")
    }
    return user
}
```

### Phase 5: Update Configuration
Add Clerk secret key to `api/internal/config/config.go`:
```go
type AppConfig struct {
    // ... existing fields ...
    ClerkSecretKey string
}

func LoadFromEnv() (AppConfig, error) {
    cfg := AppConfig{
        // ... existing fields ...
        ClerkSecretKey: os.Getenv("CLERK_SECRET_KEY"),
    }
    
    // Validation (optional, could skip in dev)
    if cfg.ClerkSecretKey == "" {
        log.Warn().Msg("CLERK_SECRET_KEY not set - authentication will not work")
    }
    
    return cfg, nil
}
```

### Phase 6: Initialize in main.go
Update `api/cmd/server/main.go` to initialize Clerk:
```go
import (
    "github.com/stwalsh4118/mirageapi/internal/auth"
)

func main() {
    // ... existing setup ...
    
    // Initialize Clerk client
    if cfg.ClerkSecretKey != "" {
        if err := auth.InitClerkClient(cfg.ClerkSecretKey); err != nil {
            log.Fatal().Err(err).Msg("failed to initialize Clerk client")
        }
        log.Info().Msg("clerk authentication initialized")
    }
    
    // ... rest of main ...
}
```

## Verification

### Implementation Checklist
- [ ] `auth` package created with all files
- [ ] Clerk client initialization function
- [ ] RequireAuth middleware function
- [ ] Token extraction from Authorization header
- [ ] JWT verification using Clerk SDK
- [ ] User loading from database
- [ ] Context helpers (GetCurrentUser, GetCurrentUserID)
- [ ] LastSeenAt update logic (throttled, async)
- [ ] IsActive check
- [ ] Configuration updated with ClerkSecretKey
- [ ] main.go initializes Clerk client

### Error Handling Checklist
- [ ] Missing Authorization header → 401
- [ ] Malformed Authorization header → 401
- [ ] Invalid/expired JWT → 401
- [ ] User not found in database → 404
- [ ] Inactive user → 403
- [ ] Database errors → 500
- [ ] Error messages are clear and actionable

### Context Helpers Checklist
- [ ] GetCurrentUser returns user or error
- [ ] GetCurrentUserID returns ID or error
- [ ] Errors when user not in context
- [ ] Type-safe (returns *store.User, not interface{})

## Test Plan

**Objective**: Verify JWT verification middleware correctly authenticates requests

**Test Scope**: Middleware function, error handling, context propagation

**Mocking Strategy**:
- Mock Clerk SDK's VerifyToken method
- Use real in-memory database for User queries
- Mock Gin context for unit tests

**Key Test Scenarios**:

1. **Valid JWT with Existing User**
   - Given: Valid JWT with clerk_user_id "user_abc", user exists in DB
   - When: Middleware processes request
   - Then: User loaded and added to context, request continues

2. **Missing Authorization Header**
   - Given: Request without Authorization header
   - When: Middleware processes request
   - Then: 401 response, request aborted

3. **Malformed Authorization Header**
   - Given: Authorization header "Invalid format"
   - When: Middleware processes request
   - Then: 401 response with format error message

4. **Invalid JWT**
   - Given: JWT that fails verification
   - When: Middleware processes request
   - Then: 401 response, request aborted

5. **Expired JWT**
   - Given: Expired but otherwise valid JWT
   - When: Middleware processes request
   - Then: 401 response, request aborted

6. **Valid JWT, User Not in Database**
   - Given: Valid JWT with clerk_user_id "user_xyz", no user in DB
   - When: Middleware processes request
   - Then: 404 response (webhook lag scenario)

7. **Valid JWT, Inactive User**
   - Given: Valid JWT, user exists but IsActive=false
   - When: Middleware processes request
   - Then: 403 response, request aborted

8. **Context Helpers Work**
   - Given: Request authenticated successfully
   - When: Handler calls GetCurrentUser()
   - Then: Returns user from context

9. **Context Helpers Error When No User**
   - Given: Request not authenticated
   - When: Handler calls GetCurrentUser()
   - Then: Returns ErrUserNotInContext error

10. **LastSeenAt Updates (First Time)**
    - Given: User with LastSeenAt=nil
    - When: User makes authenticated request
    - Then: LastSeenAt updated to current time

11. **LastSeenAt Throttled (Recent Update)**
    - Given: User with LastSeenAt=30 minutes ago
    - When: User makes authenticated request
    - Then: LastSeenAt NOT updated (throttled)

12. **LastSeenAt Updates (After Throttle)**
    - Given: User with LastSeenAt=2 hours ago
    - When: User makes authenticated request
    - Then: LastSeenAt updated to current time

**Success Criteria**:
- All test scenarios pass
- Error responses have correct status codes
- Error messages are clear and actionable
- Context helpers work correctly
- LastSeenAt throttling works
- No panics or crashes

## Files Modified

- `api/internal/auth/middleware.go` - Create RequireAuth middleware
- `api/internal/auth/context.go` - Create context helper functions
- `api/internal/auth/clerk.go` - Create Clerk client initialization
- `api/internal/auth/auth_test.go` - Create unit tests
- `api/internal/config/config.go` - Add ClerkSecretKey field
- `api/cmd/server/main.go` - Initialize Clerk client at startup
- `go.mod` / `go.sum` - Add `github.com/clerk/clerk-sdk-go/v2` dependency

## Notes

### Design Decisions

**Context Key Strategy**:
- Use string constant `contextKeyUser` (not exported)
- Only access via helper functions (GetCurrentUser)
- Type-safe: helpers return `*store.User`, not `interface{}`

**LastSeenAt Throttling**:
- Update max once per hour to reduce DB writes
- Async update (goroutine) to not block request
- Failure to update doesn't fail request
- Future: Could batch updates or use Redis cache

**User Not Found Handling**:
- Return 404, not 401
- Scenario: User signs up in Clerk, webhook hasn't processed yet
- Message tells user to "try again in a moment"
- Alternative: Could trigger sync webhook call (more complex)

**Inactive User Handling**:
- Check IsActive flag
- Return 403 Forbidden
- Webhook sets IsActive=false when user deleted in Clerk
- Prevents deleted users from accessing API

**Error Logging**:
- Log all auth failures at Debug level (not Error)
- Failed auth is expected behavior
- Only log Internal Server Error at Error level
- Include context (user ID, error details) for debugging

### Security Considerations

**Token Expiration**:
- Clerk SDK handles expiration check
- Default Clerk session tokens expire after configured time
- No manual expiration check needed

**JWKS Key Caching**:
- Clerk SDK caches public keys automatically
- Keys refreshed when needed
- No manual cache management required

**Timing Attacks**:
- Use constant-time comparison where appropriate
- Clerk SDK handles JWT signature verification safely

**Rate Limiting** (future):
- Consider adding rate limiting middleware
- Prevent brute force attacks
- Not in scope for this task

### Performance Considerations

**Database Query**:
- User loaded on every authenticated request
- Query by ClerkUserID (indexed)
- Consider caching user in session (future optimization)
- For MVP, direct DB query is acceptable

**LastSeenAt Update**:
- Async to not block request
- Throttled to reduce DB writes
- Trade-off: Last seen time is approximate (up to 1 hour old)

**Middleware Order**:
- Apply after CORS, logging, recovery
- Apply before any handler that needs authentication
- Order matters - ensure proper middleware chain

### Integration Points

**Task 16-10 Will Apply This**:
- Task 16-10 adds `RequireAuth(db)` to route groups
- All environment/service endpoints get authentication

**Task 16-7 & 16-8 Will Use This**:
- Controllers call `GetCurrentUserID()` to get authenticated user
- Filter queries: `WHERE user_id = ?`
- Verify ownership: `environment.UserID == currentUserID`

**Task 16-6 (Webhooks) Creates Users**:
- Webhook handler creates User records
- RequireAuth loads those users
- User must exist before authentication works

### Testing Strategy

**Unit Tests** (this task):
- Mock Clerk SDK
- Test middleware logic in isolation
- Test context helpers
- Test error cases

**Integration Tests** (task 16-19):
- Real Clerk test tokens
- Real database
- End-to-end auth flow
- Test with actual controllers

**E2E Tests** (task 16-20):
- Full sign-up → authentication → API call flow
- Browser-based testing
- Verify token sent from frontend


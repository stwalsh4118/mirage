# [16-10] Apply authentication middleware to all protected routes

[Back to task list](./tasks.md)

## Description

Apply the RequireAuth middleware to all API routes that should be protected, ensuring only authenticated users can access environment and service management endpoints. Leave public endpoints (healthz, webhooks) unprotected.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-07 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |

## Requirements

1. **Protected Routes**:
   - All `/api/v1/` routes EXCEPT healthz and webhooks
   - Environment provisioning and management
   - Service provisioning and management
   - User profile endpoints
   - Discovery endpoints
   - Logs endpoints

2. **Public Routes**:
   - `/api/v1/healthz` - Health check endpoint
   - `/api/webhooks/clerk` - Clerk webhook handler

3. **Middleware Application**:
   - Apply to route groups for efficiency
   - Pass database connection to middleware
   - Maintain proper middleware order

## Implementation Plan

### Phase 1: Update Server Setup
Update `api/internal/server/server.go`:

```go
func NewHTTPServer(cfg config.AppConfig, deps ...any) *gin.Engine {
    // ... existing setup ...
    
    api := r.Group("/api")
    
    // Public webhook endpoints (no auth)
    if db != nil && cfg.ClerkWebhookSecret != "" {
        webhookHandler := webhooks.NewClerkWebhookHandler(db, cfg.ClerkWebhookSecret)
        api.POST("/webhooks/clerk", webhookHandler.HandleWebhook)
    }
    
    // v1 API routes
    v1 := api.Group("/v1")
    
    // Public health endpoint
    v1.GET("/healthz", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "status": "ok",
            "env":    cfg.Environment,
        })
    })
    
    // Apply authentication middleware to all other v1 routes
    if db != nil {
        // Create authenticated route group
        authed := v1.Group("")
        authed.Use(auth.RequireAuth(db))
        {
            // Register all protected controllers
            ec := &controller.EnvironmentController{DB: db, Railway: rw}
            ec.RegisterRoutes(authed)
            
            sc := &controller.ServicesController{Railway: rw, DB: db}
            sc.RegisterRoutes(authed)
            
            lc := &controller.LogsController{DB: db, Railway: rw, AllowedOrigins: cfg.AllowedOrigins}
            lc.RegisterRoutes(authed)
            
            dc := &controller.DiscoveryController{Scanner: githubScanner}
            dc.RegisterRoutes(authed)
            
            uc := &controller.UserController{DB: db}
            uc.RegisterRoutes(authed)
        }
    }
    
    return r
}
```

### Phase 2: Initialize Clerk Client
Ensure Clerk is initialized in `api/cmd/server/main.go`:

```go
func main() {
    // ... existing setup ...
    
    // Initialize Clerk authentication
    if cfg.ClerkSecretKey != "" {
        if err := auth.InitClerkClient(cfg.ClerkSecretKey); err != nil {
            log.Fatal().Err(err).Msg("failed to initialize Clerk client")
        }
        log.Info().Msg("clerk authentication initialized")
    } else {
        log.Warn().Msg("CLERK_SECRET_KEY not set - authentication disabled")
    }
    
    // ... create server ...
}
```

## Verification

### Implementation Checklist
- [ ] RequireAuth middleware applied to protected routes
- [ ] Healthz endpoint remains public
- [ ] Webhook endpoint remains public
- [ ] All controllers registered under authed group
- [ ] Clerk client initialized at startup
- [ ] Database passed to middleware

### Route Protection Checklist
- [ ] Environment endpoints protected
- [ ] Service endpoints protected
- [ ] User endpoints protected
- [ ] Discovery endpoints protected
- [ ] Logs endpoints protected
- [ ] Healthz endpoint public
- [ ] Webhook endpoint public

## Test Plan

**Key Test Scenarios**:

1. **Access Protected Route Without Auth**
   - When: GET /api/v1/railway/projects (no token)
   - Then: 401 Unauthorized

2. **Access Protected Route With Valid Auth**
   - When: GET /api/v1/users/me (with token)
   - Then: 200 OK, user profile returned

3. **Access Health Endpoint Without Auth**
   - When: GET /api/v1/healthz (no token)
   - Then: 200 OK (public endpoint)

4. **Access Webhook Endpoint**
   - When: POST /api/webhooks/clerk (no auth, but with signature)
   - Then: Signature verified, no 401

**Success Criteria**:
- Protected routes require authentication
- Public routes accessible without auth
- Proper error responses for missing auth

## Files Modified

- `api/internal/server/server.go` - Apply middleware to routes
- `api/cmd/server/main.go` - Initialize Clerk client

## Notes

### Middleware Order

**Correct Order**:
1. Recovery (panic handling)
2. Logging
3. CORS
4. Context setup (Railway project ID)
5. **Authentication** (RequireAuth)
6. Route handlers

### Public vs Protected

**Public Endpoints**:
- Health checks (monitoring)
- Webhooks (external services)
- Future: public docs, status page

**Protected Endpoints**:
- All resource management
- User profiles
- Any data access

### Development Considerations

**Local Development**:
- Can temporarily disable auth for testing
- Set CLERK_SECRET_KEY="" to disable
- Logs warning message

**Testing**:
- Use test JWT tokens
- Mock Clerk SDK for unit tests
- Integration tests with real tokens

### Integration Dependencies

**Requires**:
- Task 16-5: RequireAuth middleware
- Task 16-7/16-8: Controllers expect authenticated user

**Completes**:
- Backend authentication implementation
- Ready for frontend integration


# [16-8] Update Services controller with ownership checks

[Back to task list](./tasks.md)

## Description

Update the ServicesController to enforce resource ownership by automatically assigning UserID to new services, verifying environment ownership before creating services, and filtering all queries by authenticated user. Services must belong to user-owned environments.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-07 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |
| 2025-10-09 00:00:00 | Status Update | Proposed | InProgress | Started implementation of ownership checks | AI Agent |
| 2025-10-09 00:00:00 | Status Update | InProgress | Review | Implementation completed, all methods updated with ownership checks | AI Agent |
| 2025-10-09 00:00:00 | Status Update | Review | Done | Task approved and completed | Sean |

## Requirements

1. **Create Operations**:
   - Verify user owns the parent environment before creating services
   - Automatically set UserID from authenticated context
   - Return 403 if user tries to create service in another user's environment

2. **Read Operations**:
   - Filter GetService by UserID
   - Return 404 if service doesn't exist or doesn't belong to user

3. **Delete Operations**:
   - Verify ownership before allowing deletes
   - Return 403 if user doesn't own the service

4. **Ownership Model**:
   - Services inherit ownership from their parent environment
   - Service.UserID must match Environment.UserID
   - Double verification for defense in depth

## Implementation Plan

### Phase 1: Update ProvisionServices
In `api/internal/controller/services.go`:

```go
func (c *ServicesController) ProvisionServices(ctx *gin.Context) {
    if c.Railway == nil {
        ctx.JSON(http.StatusServiceUnavailable, gin.H{"error": "railway client not configured"})
        return
    }
    
    // Get authenticated user
    user, err := auth.GetCurrentUser(ctx)
    if err != nil {
        ctx.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
        return
    }
    
    var req ProvisionServicesRequest
    if err := ctx.ShouldBindJSON(&req); err != nil {
        ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // Verify user owns the parent environment
    var env store.Environment
    err = c.DB.Where("id = ? AND user_id = ?", req.EnvironmentID, user.ID).
        First(&env).Error
    
    if err == gorm.ErrRecordNotFound {
        ctx.JSON(http.StatusForbidden, gin.H{
            "error": "environment not found or access denied",
        })
        return
    } else if err != nil {
        log.Error().Err(err).Msg("failed to verify environment ownership")
        ctx.JSON(http.StatusInternalServerError, gin.H{
            "error": "failed to verify environment ownership",
        })
        return
    }
    
    // Validate services
    for i, s := range req.Services {
        if err := validateServiceSpec(s); err != nil {
            ctx.JSON(http.StatusBadRequest, gin.H{
                "error":   err.Error(),
                "service": s.Name,
                "index":   i,
            })
            return
        }
    }
    
    // Determine Railway environment ID
    railwayEnvID := req.RailwayEnvironmentID
    if railwayEnvID == "" {
        railwayEnvID = req.EnvironmentID
        log.Warn().Msg("RailwayEnvironmentID not provided, using EnvironmentID")
    }
    
    ids := make([]string, 0, len(req.Services))
    for _, s := range req.Services {
        // Create service in Railway
        input := railway.CreateServiceInput{
            ProjectID:     req.ProjectID,
            EnvironmentID: railwayEnvID,
            Name:          s.Name,
            // ... configure deployment type ...
        }
        
        out, err := c.Railway.CreateService(ctx, input)
        if err != nil {
            ctx.JSON(http.StatusBadGateway, gin.H{
                "error":   err.Error(),
                "service": s.Name,
                "partial": ids,
            })
            return
        }
        ids = append(ids, out.ServiceID)
        
        // Persist service to database with UserID
        if c.DB != nil {
            serviceModel, err := serviceSpecToModel(s, req.EnvironmentID, out.ServiceID)
            if err != nil {
                log.Error().Err(err).Msg("failed to convert service spec")
                continue
            }
            
            // Set UserID from authenticated user
            serviceModel.UserID = user.ID
            
            if err := c.DB.Create(&serviceModel).Error; err != nil {
                log.Error().Err(err).
                    Str("service_name", s.Name).
                    Msg("failed to persist service")
                // Don't fail request - Railway service created
            } else {
                log.Info().
                    Str("service_id", serviceModel.ID).
                    Str("user_id", user.ID).
                    Msg("persisted service with ownership")
            }
        }
    }
    
    ctx.JSON(http.StatusOK, ProvisionServicesResponse{ServiceIDs: ids})
}
```

### Phase 2: Update GetService
```go
func (c *ServicesController) GetService(ctx *gin.Context) {
    serviceID := ctx.Param("id")
    if serviceID == "" {
        ctx.JSON(http.StatusBadRequest, gin.H{"error": "service id required"})
        return
    }
    
    // Get authenticated user
    user, err := auth.GetCurrentUser(ctx)
    if err != nil {
        ctx.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
        return
    }
    
    // Query service with ownership check
    var service store.Service
    err = c.DB.Where("id = ? AND user_id = ?", serviceID, user.ID).
        First(&service).Error
    
    if err == gorm.ErrRecordNotFound {
        ctx.JSON(http.StatusNotFound, gin.H{"error": "service not found"})
        return
    } else if err != nil {
        log.Error().Err(err).Msg("failed to query service")
        ctx.JSON(http.StatusInternalServerError, gin.H{
            "error": "failed to retrieve service",
        })
        return
    }
    
    dto := serviceModelToServiceDetailDTO(service)
    ctx.JSON(http.StatusOK, dto)
}
```

### Phase 3: Update DeleteRailwayService
```go
func (c *ServicesController) DeleteRailwayService(ctx *gin.Context) {
    if c.Railway == nil {
        ctx.JSON(http.StatusServiceUnavailable, gin.H{
            "error": "railway client not configured",
        })
        return
    }
    
    railwayServiceID := ctx.Param("id")
    if railwayServiceID == "" {
        ctx.JSON(http.StatusBadRequest, gin.H{"error": "service id required"})
        return
    }
    
    // Get authenticated user
    user, err := auth.GetCurrentUser(ctx)
    if err != nil {
        ctx.JSON(http.StatusUnauthorized, gin.H{
            "error": "authentication required",
        })
        return
    }
    
    // Verify ownership before deleting
    var service store.Service
    err = c.DB.Where("railway_service_id = ? AND user_id = ?", railwayServiceID, user.ID).
        First(&service).Error
    
    if err == gorm.ErrRecordNotFound {
        ctx.JSON(http.StatusForbidden, gin.H{
            "error": "service not found or access denied",
        })
        return
    } else if err != nil {
        log.Error().Err(err).Msg("failed to verify service ownership")
        ctx.JSON(http.StatusInternalServerError, gin.H{
            "error": "failed to verify ownership",
        })
        return
    }
    
    // Delete from Railway
    log.Info().
        Str("railway_service_id", railwayServiceID).
        Str("user_id", user.ID).
        Msg("deleting railway service")
    
    err = c.Railway.DestroyService(ctx, railway.DestroyServiceInput{
        ServiceID: railwayServiceID,
    })
    
    if err != nil {
        log.Error().Err(err).Msg("railway delete service failed")
        ctx.JSON(http.StatusBadGateway, gin.H{"error": err.Error()})
        return
    }
    
    // Clean up database
    if c.DB != nil {
        result := c.DB.Where("railway_service_id = ?", railwayServiceID).
            Delete(&store.Service{})
        
        if result.Error != nil {
            log.Error().Err(result.Error).Msg("failed to delete service from database")
        } else {
            log.Info().
                Str("railway_service_id", railwayServiceID).
                Int64("rows_deleted", result.RowsAffected).
                Msg("deleted service from database")
        }
    }
    
    ctx.Status(http.StatusNoContent)
}
```

### Phase 4: Add Ownership Validation
Create helper function:
```go
// verifyEnvironmentOwnership checks if the user owns the environment
func (c *ServicesController) verifyEnvironmentOwnership(
    ctx *gin.Context,
    environmentID string,
    userID string,
) error {
    var count int64
    err := c.DB.Model(&store.Environment{}).
        Where("id = ? AND user_id = ?", environmentID, userID).
        Count(&count).Error
    
    if err != nil {
        return err
    }
    
    if count == 0 {
        return gorm.ErrRecordNotFound
    }
    
    return nil
}
```

## Verification

### Implementation Checklist
- [x] ProvisionServices verifies environment ownership
- [x] ProvisionServices sets UserID from auth context
- [x] GetService filters by user
- [x] DeleteRailwayService verifies ownership
- [x] All queries include `user_id = ?` filter
- [x] Auth import added to controller

### Security Checklist
- [ ] Cannot create service in another user's environment
- [ ] Cannot view another user's services
- [ ] Cannot delete another user's services
- [ ] 403 responses for unauthorized access
- [ ] Appropriate logging for security events

### Error Handling Checklist
- [ ] 401 when authentication fails
- [ ] 403 when ownership check fails
- [ ] 404 when resource not found
- [ ] Clear error messages

## Test Plan

**Objective**: Verify service ownership is enforced

**Test Scope**: Services controller endpoints with authentication

**Key Test Scenarios**:

1. **Create Service in Own Environment**
   - Given: User owns environment
   - When: POST /provision/services
   - Then: Service created with UserID set

2. **Create Service in Another User's Environment**
   - Given: Environment belongs to User2
   - When: User1 tries to create service
   - Then: 403 Forbidden response

3. **Get Own Service**
   - Given: User1 owns service
   - When: GET /services/:id
   - Then: Service returned

4. **Get Another User's Service**
   - Given: Service belongs to User2
   - When: User1 tries to get service
   - Then: 404 response

5. **Delete Own Service**
   - Given: User1 owns service
   - When: DELETE /railway/service/:id
   - Then: Service deleted

6. **Delete Another User's Service**
   - Given: Service belongs to User2
   - When: User1 tries to delete
   - Then: 403 Forbidden response

**Success Criteria**:
- All ownership checks pass
- Users can only access their services
- Environment ownership verified before service creation

## Files Modified

- `api/internal/controller/services.go` - Add ownership checks
  - Added auth import
  - Updated ProvisionServices to verify environment ownership and set UserID
  - Updated GetService to filter by user_id
  - Updated DeleteRailwayService to verify ownership before deleting

## Notes

### Inheritance Model

**Service Ownership**:
- Services belong to environments
- Services inherit UserID from parent environment
- Service.UserID must equal Environment.UserID
- Verified at creation time

**Defense in Depth**:
- Check environment ownership before creating service
- Store UserID in service record
- Check service ownership on reads/deletes
- Two layers of protection

### Integration Dependencies

**Requires**:
- Task 16-4: UserID column in Service model
- Task 16-5: RequireAuth middleware
- Task 16-7: Environment ownership model established

**Testing**:
- Task 16-19: Integration tests for ownership


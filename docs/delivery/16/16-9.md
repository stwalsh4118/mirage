# [16-9] Implement user profile API endpoints

[Back to task list](./tasks.md)

## Description

Create REST API endpoints for user profile management: GET and PATCH for `/api/v1/users/me`, plus endpoints to list the current user's environments and services. These endpoints enable users to view and update their profile information and see their owned resources.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-07 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |

## Requirements

1. **GET /api/v1/users/me**:
   - Return current user's profile
   - Include: id, clerkUserId, email, firstName, lastName, profileImageUrl, lastSeenAt, createdAt, updatedAt
   - Exclude: IsActive (internal field)

2. **PATCH /api/v1/users/me**:
   - Allow updating: firstName, lastName
   - Email managed by Clerk (read-only in API)
   - Return updated user object

3. **GET /api/v1/users/me/environments**:
   - List all environments owned by current user
   - Include basic environment info (not full details)
   - Support pagination (future enhancement)

4. **GET /api/v1/users/me/services**:
   - List all services owned by current user
   - Include basic service info
   - Support pagination (future enhancement)

## Implementation Plan

### Phase 1: Create User Controller
Create `api/internal/controller/user.go`:

```go
package controller

import (
    "net/http"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/rs/zerolog/log"
    "github.com/stwalsh4118/mirageapi/internal/auth"
    "github.com/stwalsh4118/mirageapi/internal/store"
    "gorm.io/gorm"
)

type UserController struct {
    DB *gorm.DB
}

func (c *UserController) RegisterRoutes(r *gin.RouterGroup) {
    users := r.Group("/users")
    {
        users.GET("/me", c.GetCurrentUser)
        users.PATCH("/me", c.UpdateCurrentUser)
        users.GET("/me/environments", c.ListCurrentUserEnvironments)
        users.GET("/me/services", c.ListCurrentUserServices)
    }
}

// UserDTO represents user data returned to clients
type UserDTO struct {
    ID              string  `json:"id"`
    ClerkUserID     string  `json:"clerkUserId"`
    Email           string  `json:"email"`
    FirstName       *string `json:"firstName,omitempty"`
    LastName        *string `json:"lastName,omitempty"`
    ProfileImageURL *string `json:"profileImageUrl,omitempty"`
    LastSeenAt      *string `json:"lastSeenAt,omitempty"`
    CreatedAt       string  `json:"createdAt"`
    UpdatedAt       string  `json:"updatedAt"`
}

// UpdateUserRequest contains fields that can be updated
type UpdateUserRequest struct {
    FirstName *string `json:"firstName"`
    LastName  *string `json:"lastName"`
}

func (c *UserController) GetCurrentUser(ctx *gin.Context) {
    user, err := auth.GetCurrentUser(ctx)
    if err != nil {
        ctx.JSON(http.StatusUnauthorized, gin.H{
            "error": "authentication required",
        })
        return
    }
    
    dto := userToDTO(user)
    ctx.JSON(http.StatusOK, dto)
}

func (c *UserController) UpdateCurrentUser(ctx *gin.Context) {
    user, err := auth.GetCurrentUser(ctx)
    if err != nil {
        ctx.JSON(http.StatusUnauthorized, gin.H{
            "error": "authentication required",
        })
        return
    }
    
    var req UpdateUserRequest
    if err := ctx.ShouldBindJSON(&req); err != nil {
        ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // Update allowed fields
    updates := map[string]interface{}{
        "updated_at": time.Now(),
    }
    
    if req.FirstName != nil {
        updates["first_name"] = req.FirstName
    }
    
    if req.LastName != nil {
        updates["last_name"] = req.LastName
    }
    
    err = c.DB.Model(&store.User{}).
        Where("id = ?", user.ID).
        Updates(updates).Error
    
    if err != nil {
        log.Error().Err(err).Str("user_id", user.ID).Msg("failed to update user")
        ctx.JSON(http.StatusInternalServerError, gin.H{
            "error": "failed to update user",
        })
        return
    }
    
    // Reload user to get updated values
    var updatedUser store.User
    if err := c.DB.First(&updatedUser, "id = ?", user.ID).Error; err != nil {
        log.Error().Err(err).Msg("failed to reload user")
        ctx.JSON(http.StatusInternalServerError, gin.H{
            "error": "failed to reload user",
        })
        return
    }
    
    dto := userToDTO(&updatedUser)
    ctx.JSON(http.StatusOK, dto)
}

func (c *UserController) ListCurrentUserEnvironments(ctx *gin.Context) {
    user, err := auth.GetCurrentUser(ctx)
    if err != nil {
        ctx.JSON(http.StatusUnauthorized, gin.H{
            "error": "authentication required",
        })
        return
    }
    
    var environments []store.Environment
    err = c.DB.Where("user_id = ?", user.ID).
        Order("created_at DESC").
        Find(&environments).Error
    
    if err != nil {
        log.Error().Err(err).Msg("failed to query user environments")
        ctx.JSON(http.StatusInternalServerError, gin.H{
            "error": "failed to retrieve environments",
        })
        return
    }
    
    ctx.JSON(http.StatusOK, environments)
}

func (c *UserController) ListCurrentUserServices(ctx *gin.Context) {
    user, err := auth.GetCurrentUser(ctx)
    if err != nil {
        ctx.JSON(http.StatusUnauthorized, gin.H{
            "error": "authentication required",
        })
        return
    }
    
    var services []store.Service
    err = c.DB.Where("user_id = ?", user.ID).
        Order("created_at DESC").
        Find(&services).Error
    
    if err != nil {
        log.Error().Err(err).Msg("failed to query user services")
        ctx.JSON(http.StatusInternalServerError, gin.H{
            "error": "failed to retrieve services",
        })
        return
    }
    
    ctx.JSON(http.StatusOK, services)
}

func userToDTO(user *store.User) UserDTO {
    dto := UserDTO{
        ID:              user.ID,
        ClerkUserID:     user.ClerkUserID,
        Email:           user.Email,
        FirstName:       user.FirstName,
        LastName:        user.LastName,
        ProfileImageURL: user.ProfileImageURL,
        CreatedAt:       user.CreatedAt.UTC().Format(time.RFC3339),
        UpdatedAt:       user.UpdatedAt.UTC().Format(time.RFC3339),
    }
    
    if user.LastSeenAt != nil {
        lastSeen := user.LastSeenAt.UTC().Format(time.RFC3339)
        dto.LastSeenAt = &lastSeen
    }
    
    return dto
}
```

### Phase 2: Register Routes
Update `api/internal/server/server.go`:

```go
func NewHTTPServer(cfg config.AppConfig, deps ...any) *gin.Engine {
    // ... existing setup ...
    
    v1 := api.Group("/v1")
    if db != nil {
        // Existing controllers
        ec := &controller.EnvironmentController{DB: db, Railway: rw}
        ec.RegisterRoutes(v1)
        
        sc := &controller.ServicesController{Railway: rw, DB: db}
        sc.RegisterRoutes(v1)
        
        // ... other controllers ...
        
        // User controller (new)
        uc := &controller.UserController{DB: db}
        uc.RegisterRoutes(v1)
    }
    
    // ... rest of setup ...
}
```

## Verification

### Implementation Checklist
- [ ] UserController created
- [ ] GET /users/me endpoint implemented
- [ ] PATCH /users/me endpoint implemented
- [ ] GET /users/me/environments endpoint implemented
- [ ] GET /users/me/services endpoint implemented
- [ ] UserDTO excludes internal fields
- [ ] Routes registered in server
- [ ] Only firstName and lastName are updatable

### Security Checklist
- [ ] All endpoints require authentication
- [ ] Users can only access their own data
- [ ] Email cannot be changed via API
- [ ] Internal fields (IsActive) not exposed
- [ ] Sensitive data properly handled

## Test Plan

**Key Test Scenarios**:

1. **Get Current User Profile**
   - Given: User authenticated
   - When: GET /users/me
   - Then: User profile returned

2. **Update User Name**
   - Given: User authenticated
   - When: PATCH /users/me with firstName and lastName
   - Then: User updated, new values returned

3. **List User's Environments**
   - Given: User has 3 environments
   - When: GET /users/me/environments
   - Then: All 3 environments returned

4. **List User's Services**
   - Given: User has 5 services
   - When: GET /users/me/services
   - Then: All 5 services returned

**Success Criteria**:
- All endpoints work correctly
- Only allowed fields can be updated
- Data properly filtered by user

## Files Modified

- `api/internal/controller/user.go` - Create new controller
- `api/internal/controller/user_test.go` - Create tests
- `api/internal/server/server.go` - Register user routes

## Notes

### Field-Level Permissions

**Read-Only Fields**:
- id, clerkUserId, email, createdAt, updatedAt, lastSeenAt
- Managed by system or Clerk

**Updatable Fields**:
- firstName, lastName
- Directly updatable by user

**Hidden Fields**:
- IsActive (internal)
- Not exposed in API responses

### Future Enhancements

**Pagination** (not in scope):
- Add `?limit=` and `?offset=` query params
- Return total count in response headers
- Implement in subsequent PBI

**Filtering** (not in scope):
- Filter environments by type
- Filter services by status
- Implement in subsequent PBI

### Integration Dependencies

**Requires**:
- Task 16-3: User model
- Task 16-5: RequireAuth middleware
- Task 16-7/16-8: User owns environments/services


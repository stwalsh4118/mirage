# Mirage ID Strategy

**Date**: 2025-10-04  
**Status**: Implemented

## Problem

There was inconsistency in how Railway IDs vs Mirage internal IDs were being used throughout the codebase, leading to:
- Foreign key mismatches (services couldn't be found when deleting environments)
- Confusion about which ID to use where
- Failed database queries

## Solution: Clear ID Separation

### Mirage Internal IDs
**Purpose**: Primary keys and foreign keys within our database  
**Format**: UUIDs generated by `uuid.New().String()`  
**Usage**:
- `Environment.ID` - Primary key for environments table
- `Service.EnvironmentID` - Foreign key pointing to Environment.ID
- `EnvironmentMetadata.EnvironmentID` - Foreign key pointing to Environment.ID

### Railway IDs
**Purpose**: Identifying resources in Railway's API  
**Format**: Railway's internal ID format  
**Usage**:
- `Environment.RailwayEnvironmentID` - Stored for Railway API calls
- `Environment.RailwayProjectID` - Stored for Railway API calls
- `Service.RailwayServiceID` - Stored for Railway API calls

## Implementation

### Backend API Responses

#### ProvisionProject
**Returns**:
```json
{
  "projectId": "<railway-project-id>",
  "baseEnvironmentId": "<mirage-env-id>",      // ← For frontend foreign keys
  "railwayEnvironmentId": "<railway-env-id>",  // ← For Railway API calls
  "name": "<project-name>"
}
```

#### ProvisionEnvironment
**Returns**:
```json
{
  "environmentId": "<mirage-env-id>",        // ← For frontend foreign keys
  "railwayEnvironmentId": "<railway-env-id>" // ← For Railway API calls
}
```

#### ProvisionServices
**Expects**:
```json
{
  "projectId": "<railway-project-id>",
  "environmentId": "<mirage-env-id>",  // ← Uses Mirage ID for FK
  "services": [...]
}
```

### Database Schema

```sql
-- Environments table
CREATE TABLE environments (
  id TEXT PRIMARY KEY,                    -- Mirage internal ID (UUID)
  railway_environment_id TEXT,            -- Railway's ID for this environment
  railway_project_id TEXT,                -- Railway's project ID
  ...
);

-- Services table
CREATE TABLE services (
  id TEXT PRIMARY KEY,                    -- Mirage internal ID (UUID)
  environment_id TEXT NOT NULL,           -- FK → environments.id (Mirage ID)
  railway_service_id TEXT,                -- Railway's ID for this service
  ...
  FOREIGN KEY (environment_id) REFERENCES environments(id)
);

-- Metadata table  
CREATE TABLE environment_metadata (
  id TEXT PRIMARY KEY,                    -- Mirage internal ID (UUID)
  environment_id TEXT NOT NULL,           -- FK → environments.id (Mirage ID)
  ...
  FOREIGN KEY (environment_id) REFERENCES environments(id)
);
```

### API Endpoint Patterns

#### Query by Railway ID
When frontend has a Railway ID (e.g., from Railway API responses):
```go
// GET /environments/:railway-env-id/metadata
var env store.Environment
db.Where("railway_environment_id = ?", railwayEnvID).First(&env)
// Then use env.ID for FK queries
```

#### Delete by Railway ID
```go
// DELETE /railway/environment/:railway-env-id
1. Delete from Railway using Railway ID
2. Look up Mirage environment by railway_environment_id
3. Delete children using Mirage ID foreign keys
```

## Rules

1. **Frontend receives Mirage IDs** for all resources that need foreign key relationships
2. **Railway IDs are supplementary** and only used for Railway API calls
3. **Foreign keys always use Mirage IDs** to maintain referential integrity
4. **Lookups by Railway ID** must first resolve to Mirage ID before querying children

## Migration Impact

### Fixed Files
- `api/internal/controller/projects.go` - ProvisionProject now returns Mirage ID
- `api/internal/controller/environment.go` - ProvisionEnvironment now returns Mirage ID
- Both endpoints include `railwayEnvironmentId` for Railway API calls

### Frontend Changes Required
- Update response type definitions to include `railwayEnvironmentId`
- Frontend should use `environmentId` (Mirage ID) for provisioning services
- Frontend should use `railwayEnvironmentId` when calling Railway-specific delete endpoints

## Benefits

1. **Data Integrity**: Foreign keys work correctly
2. **Clear Semantics**: ID naming makes purpose obvious
3. **Consistent Deletion**: Children can always be found and deleted
4. **API Clarity**: Response structure documents which ID is for what purpose


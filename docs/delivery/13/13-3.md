# [13-3] Implement database persistence in provision endpoints

[Back to task list](./tasks.md)

## Description

Add database writes to the provision endpoints (`ProvisionProject`, `ProvisionEnvironment`, `ProvisionServices`) so that all wizard-created resources are persisted to our database. Currently these endpoints only call Railway API and return IDs without saving anything locally.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-03 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |

## Requirements

1. **ProvisionProject**: Save project and base environment to database
2. **ProvisionEnvironment**: Save environment record to database
3. **ProvisionServices**: Save service records with full build configuration
4. Capture complete wizard inputs and store in EnvironmentMetadata
5. Store provision outputs (Railway IDs) in EnvironmentMetadata
6. Handle errors and transactions properly
7. Return same response format as before (backwards compatible)

## Implementation Plan

### Update ProvisionProject (projects.go):
1. After Railway.CreateProject succeeds:
   - Create `store.Environment` record with:
     - Generated ID, Name, Type, Status
     - RailwayProjectID and RailwayEnvironmentID
   - Insert into database
2. Handle database errors appropriately

### Update ProvisionEnvironment (environment.go):
1. Accept wizard metadata in request (optional for now)
2. After Railway.CreateEnvironment succeeds:
   - Create `store.Environment` record
   - Create `store.EnvironmentMetadata` record with wizard inputs
   - Insert both in transaction
3. Return same response format

### Update ProvisionServices (services.go):
1. After each Railway.CreateService succeeds:
   - Create `store.Service` record with:
     - All existing fields (Name, Path, Status, etc.)
     - New build config fields (DockerfilePath, BuildArgsJSON, etc.)
   - Insert into database
2. Store build args and exposed ports as JSON
3. Handle both repo and image deployment types

### JSON Marshaling Helpers:
1. Create helper to convert ServiceSpec to Service model
2. Marshal build args and ports to JSON strings
3. Handle nil/empty values properly

## Verification

- Provision endpoints still return same response format
- Database records are created successfully
- Railway IDs are stored correctly
- Build configuration is persisted
- Errors are handled gracefully

## Test Plan

**Objective**: Verify provision endpoints persist data to database

**Test Scope**: Integration tests for provision endpoints

**Key Test Scenarios**:
1. Provision new project - verify Environment and EnvironmentMetadata created
2. Provision environment in existing project - verify database records
3. Provision repository-based services - verify Service records with Dockerfile path
4. Provision image-based services - verify Service records with image details
5. Verify build args and ports stored as JSON
6. Test transaction rollback on database errors
7. Verify backwards compatibility - response format unchanged

**Success Criteria**:
- All provision endpoints save to database
- Railway API calls and database writes both succeed
- JSON fields store complex data correctly
- Error handling prevents partial writes
- API responses remain backwards compatible

## Files Modified

- `api/internal/controller/projects.go` - Add DB writes to ProvisionProject
- `api/internal/controller/environment.go` - Add DB writes to ProvisionEnvironment
- `api/internal/controller/services.go` - Add DB writes to ProvisionServices
- `api/internal/controller/services_test.go` - Update integration tests
- `api/internal/controller/environment_test.go` - Add/update tests

# [12-7] E2E CoS Test

[Back to task list](./tasks.md)

## Description
End-to-end testing to verify all Conditions of Satisfaction for PBI 12 are met. This includes comprehensive testing of Dockerfile discovery, service selection, configuration, and successful deployment to Railway.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-01 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |

## Requirements

Verify all PBI 12 Acceptance Criteria:
1. ✅ Scanner recursively finds all `Dockerfile` files in repository
2. ✅ Scanner detects `*.dockerfile` variants (e.g., `production.dockerfile`)
3. ✅ Build context is correctly identified for each Dockerfile
4. ✅ EXPOSE directives are parsed and extracted
5. ✅ ARG directives are detected and presented for override
6. ✅ UI displays discovered services in tree structure
7. ✅ Users can select/deselect services for deployment
8. ✅ Configuration can be overridden before deployment
9. ✅ Multi-service deployment creates all selected services
10. ✅ Discovery results are cached and can be refreshed
11. ✅ Error handling for malformed Dockerfiles

## Implementation Plan

1. Create test repository fixtures:
   - Monorepo with multiple services
   - Various Dockerfile locations and names
   - Mix of Node.js, Go, Python services
   - Some with EXPOSE and ARG directives

2. Create E2E test suite in appropriate location:
   - `test/e2e/dockerfile-discovery.test.ts` or similar

3. Test scenarios (see Test Plan below)

4. Document test results and any issues found

5. Create test data cleanup procedures

## Verification

All test scenarios pass:
- [ ] Test 1: Basic discovery
- [ ] Test 2: Dockerfile variants
- [ ] Test 3: Metadata parsing
- [ ] Test 4: Selective deployment
- [ ] Test 5: Name overrides
- [ ] Test 6: Error handling
- [ ] Test 7: Cache/refresh
- [ ] Test 8: Full wizard integration
- [ ] All PBI CoS verified
- [ ] No critical bugs found
- [ ] Performance is acceptable (<5s for typical monorepo scan)

## Test Plan

### Test Scenario 1: Basic Dockerfile Discovery
**Setup**: Create test monorepo:
```
test-repo/
  services/
    api/
      Dockerfile
      package.json
    worker/
      Dockerfile
      package.json
    frontend/
      Dockerfile
      package.json
```

**Steps**:
1. Call discovery API with test repo path
2. Verify response contains 3 services
3. Verify service names: "api", "worker", "frontend"
4. Verify Dockerfile paths are correct relative paths

**Expected**: All 3 services discovered with correct metadata

---

### Test Scenario 2: Dockerfile Variants
**Setup**: Repository with multiple Dockerfile types:
```
service/
  Dockerfile
  Dockerfile.prod
  development.dockerfile
```

**Steps**:
1. Scan repository
2. Verify all 3 Dockerfiles discovered

**Expected**: Scanner finds all Dockerfile variants

---

### Test Scenario 3: Metadata Parsing
**Setup**: Dockerfile with comprehensive directives:
```dockerfile
FROM node:18-alpine
ARG NODE_ENV=production
ARG VERSION
ARG BUILD_DATE
EXPOSE 3000
EXPOSE 9090
WORKDIR /app
```

**Steps**:
1. Scan repository
2. Verify parsed metadata

**Expected**:
- Base image: "node:18-alpine"
- Build args: ["NODE_ENV", "VERSION", "BUILD_DATE"]
- Exposed ports: [3000, 9090]

---

### Test Scenario 4: Selective Service Deployment
**Setup**: Monorepo with 5 services

**Steps**:
1. Complete discovery through UI
2. Select 3 out of 5 services
3. Complete wizard
4. Verify Railway environment

**Expected**:
- Only 3 services created in Railway
- Each service has RAILWAY_DOCKERFILE_PATH variable set
- Services can build and deploy successfully

---

### Test Scenario 5: Service Name Overrides
**Setup**: Discovered service named "api"

**Steps**:
1. Discovery finds service "api"
2. User renames to "backend-api" in UI
3. Complete provisioning

**Expected**:
- Railway service created with name "backend-api"
- Correct Dockerfile path still used

---

### Test Scenario 6: Error Handling
**Test 6a - No Dockerfiles Found**:
- Repository with only source code
- Expected: Empty results, friendly message, no error

**Test 6b - Malformed Dockerfile**:
- Dockerfile with syntax errors
- Expected: Service still discovered, parsing errors logged but don't block

**Test 6c - Invalid Repository Path**:
- Non-existent path
- Expected: Clear error message

---

### Test Scenario 7: Discovery Caching (if implemented)
**Steps**:
1. Scan repository
2. Note response time
3. Scan same repository immediately
4. Compare response times

**Expected**: Second scan returns cached results (much faster)

---

### Test Scenario 8: Full Wizard Integration
**Steps**:
1. Open environment creation wizard
2. Select/enter repository
3. Click "Scan for Dockerfiles"
4. Wait for discovery results
5. Select 2 services
6. Rename 1 service
7. Continue through wizard
8. Complete environment creation

**Expected**:
- Smooth wizard flow
- Services created with correct Dockerfile paths
- Deployments succeed
- Services accessible in Railway

---

### Test Scenario 9: Real-World Monorepo
**Setup**: Use actual monorepo (e.g., Turborepo example, Nx example)

**Steps**:
1. Point discovery at real monorepo
2. Verify sensible results
3. Measure performance

**Expected**:
- Reasonable discovery time (<5s)
- Accurate service detection
- No crashes or errors

---

### Test Scenario 10: Nested Directory Structures
**Setup**: Deeply nested Dockerfiles:
```
packages/
  backend/
    services/
      auth/
        Dockerfile
      api/
        Dockerfile
```

**Steps**:
1. Scan repository
2. Verify services discovered
3. Check service name inference

**Expected**: Both services found with sensible names ("auth", "api")

## Files Modified

- `test/e2e/dockerfile-discovery.test.ts` (new)
- Test fixture repositories (new)
- Test documentation with results (new)


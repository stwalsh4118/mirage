# [12-4] Create Dockerfile discovery API endpoint

[Back to task list](./tasks.md)

## Description
Create REST API endpoint that accepts a repository URL (or references an existing project's repo), triggers Dockerfile scanning, and returns discovered Dockerfiles with metadata for frontend consumption.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-01 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |

## Requirements

1. Create new endpoint: `POST /api/v1/discovery/dockerfiles`
   
   **Request Body:**
   ```json
   {
     "repoUrl": "string",
     "branch": "string",
     "requestId": "string"
   }
   ```

   **Response:**
   ```json
   {
     "services": [
       {
         "name": "string",
         "dockerfilePath": "string",
         "buildContext": "string",
         "exposedPorts": [3000, 9090],
         "buildArgs": ["NODE_ENV", "VERSION"],
         "baseImage": "string"
       }
     ]
   }
   ```

2. Implementation approach (choose based on complexity):
   - **Option A (Simple)**: Accept repo that's already cloned/accessible on filesystem
   - **Option B (Full)**: Clone repo temporarily, scan, cleanup

3. For MVP, recommend Option A:
   - Assume repo is available at a known path or will be provided by frontend
   - Frontend can handle git clone client-side or use Railway's existing repo connection

4. Error handling:
   - Invalid repo URL/path
   - No Dockerfiles found
   - Scan errors (permissions, malformed Dockerfiles)

5. Response caching consideration:
   - For same repo+branch+commit, cache results
   - TTL-based expiration (e.g., 5 minutes)

## Implementation Plan

1. Create `api/internal/controller/discovery.go`:
   - Implement `DiscoveryController` struct
   - Implement `DiscoverDockerfiles` handler
   - Use scanner from task 12-2

2. For MVP (Option A - filesystem based):
   ```go
   type DiscoverDockerfilesRequest struct {
       RepoPath  string `json:"repoPath"`  // Filesystem path to cloned repo
       Branch    string `json:"branch"`
       RequestID string `json:"requestId"`
   }
   ```

3. Handler logic:
   - Validate request
   - Call `scanner.ScanForDockerfiles(repoPath)`
   - Transform `DockerfileInfo` to API response format
   - Return JSON response

4. Register route in server setup

5. Add request/response logging

6. Consider security:
   - Validate repo path doesn't escape expected boundaries
   - Sanitize file paths in responses

## Verification

- [ ] Endpoint responds to POST requests
- [ ] Successfully scans repository and returns Dockerfiles
- [ ] Response includes all required metadata fields
- [ ] Handles repositories with no Dockerfiles gracefully
- [ ] Returns appropriate error messages for invalid inputs
- [ ] Response format matches TypeScript frontend types
- [ ] Logging captures request/response details

## Test Plan

### Unit Tests
1. Test request validation:
   - Empty repo path rejected
   - Invalid path format rejected

2. Test response transformation:
   - Scanner results correctly mapped to API response
   - All fields populated correctly

### Integration Tests
1. **Test Case**: Repository with multiple services
   - Setup: Create test repo with services/ directory containing 3 Dockerfiles
   - Execute: POST to endpoint with repo path
   - Verify: Response contains 3 services with correct metadata

2. **Test Case**: Repository with no Dockerfiles
   - Setup: Create test repo with only source code
   - Execute: POST to endpoint
   - Verify: Response contains empty services array (not error)

3. **Test Case**: Repository with nested Dockerfiles
   - Setup: Repo with packages/backend/services/api/Dockerfile
   - Execute: POST to endpoint
   - Verify: Service name inferred correctly, path is complete

### Manual Testing
1. Test with real monorepo structure
2. Verify response time is reasonable (<2s for typical repo)
3. Verify log output is helpful for debugging

## Files Modified

- `api/internal/controller/discovery.go` (new)
- `api/internal/server/server.go` (update routes)
- `api/internal/controller/discovery_test.go` (new)


# [14-10] Integrate LogViewer into environment detail page

[Back to task list](./tasks.md)

## Description

Integrate all the log viewing components into the existing environment detail page, creating a cohesive logs tab or section that allows users to view, filter, search, and stream logs for their environments directly within the Mirage interface.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-04 00:00:00 | Created | N/A | Proposed | Task file created | ai-agent |

## Requirements

1. **Integration Point**:
   - Add logs viewing section to the environment detail page (project-detail.tsx)
   - Option 1: Tab-based UI (Logs tab alongside Services, Metadata)
   - Option 2: Expandable section below services
   - Maintain consistent styling with existing sections

2. **Data Fetching**:
   - Fetch historical logs when logs section opened
   - Enable WebSocket streaming with toggle
   - Apply filters to both historical and streaming logs

3. **State Management**:
   - Track selected environment
   - Manage filter state
   - Coordinate between historical fetch and streaming
   - Persist filter preferences (optional)

4. **UI Layout**:
   - LogFilterControls at the top
   - LogViewer in the main area
   - StreamStatus indicator
   - Responsive design matching existing patterns

5. **Performance**:
   - Lazy load logs section (don't fetch until opened)
   - Unsubscribe from WebSocket when section closed
   - Clean up resources on environment change

6. **User Experience**:
   - Smooth transitions when opening/closing
   - Loading states for initial load
   - Empty state when no logs available
   - Link from "View Logs" quick action button

## Implementation Plan

1. **Update ProjectDetail Component** in `web/src/components/project/project-detail.tsx`:
   ```tsx
   import { useState } from 'react'
   import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
   import { LogsSection } from '@/components/logs/LogsSection'

   export function ProjectDetail({ projectId }: ProjectDetailProps) {
     const [selectedEnvironment, setSelectedEnvironment] = useState<string | null>(null)
     const [activeTab, setActiveTab] = useState<'services' | 'metadata' | 'logs'>('services')

     const selectedEnv = environments.find((env) => env.id === selectedEnvironment)

     return (
       <div className="container mx-auto px-4 py-6 space-y-6">
         {/* ... existing code ... */}

         {/* Environment Details Tabs */}
         {selectedEnv && (
           <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as any)}>
             <TabsList className="glass grain">
               <TabsTrigger value="services">Services</TabsTrigger>
               <TabsTrigger value="metadata">Metadata</TabsTrigger>
               <TabsTrigger value="logs">Logs</TabsTrigger>
             </TabsList>

             <TabsContent value="services">
               {/* Existing services content */}
               <Card className="glass grain">
                 <CardHeader>
                   <CardTitle>Services in {selectedEnv.name}</CardTitle>
                 </CardHeader>
                 <CardContent>
                   <ServicesList services={selectedEnv.services} />
                 </CardContent>
               </Card>
             </TabsContent>

             <TabsContent value="metadata">
               {/* Existing metadata content */}
               <EnvironmentMetadata
                 environmentId={selectedEnv.id}
                 onSaveAsTemplate={() => {}}
               />
             </TabsContent>

             <TabsContent value="logs">
               <LogsSection
                 environmentId={selectedEnv.id}
                 environmentName={selectedEnv.name}
                 services={selectedEnv.services}
               />
             </TabsContent>
           </Tabs>
         )}
       </div>
     )
   }
   ```

2. **Create LogsSection Component** in `web/src/components/logs/LogsSection.tsx`:
   ```tsx
   import { useState, useEffect } from 'react'
   import { Card } from '@/components/ui/card'
   import { LogViewer } from './LogViewer'
   import { LogFilterControls } from './LogFilterControls'
   import { StreamStatus } from './StreamStatus'
   import { useLogStream } from '@/hooks/useLogStream'
   import { useLogExport } from '@/hooks/useLogExport'
   import type { LogFilters } from './types'

   interface LogsSectionProps {
     environmentId: string
     environmentName: string
     services: Service[]
   }

   export function LogsSection({ environmentId, environmentName, services }: LogsSectionProps) {
     const [filters, setFilters] = useState<LogFilters>({
       services: [],
       from: new Date(Date.now() - 60 * 60 * 1000), // Last 1 hour
       to: null,
       search: '',
       regexMode: false,
       levels: ['DEBUG', 'INFO', 'WARN', 'ERROR'],
       autoScroll: true,
       streaming: true,
     })

     const [historicalLogs, setHistoricalLogs] = useState<Log[]>([])
     const [loadingHistorical, setLoadingHistorical] = useState(false)

     // WebSocket streaming
     const {
       logs: streamLogs,
       status: streamStatus,
       error: streamError,
       connect: connectStream,
       disconnect: disconnectStream,
       clear: clearStreamLogs,
     } = useLogStream({
       environmentId,
       filters: {
         services: filters.services,
         search: filters.search,
         levels: filters.levels,
       },
       enabled: filters.streaming,
     })

     // Fetch historical logs
     useEffect(() => {
       const fetchHistoricalLogs = async () => {
         setLoadingHistorical(true)
         try {
           const params = new URLSearchParams()
           params.set('limit', '1000')
           if (filters.services.length) {
             params.set('services', filters.services.join(','))
           }
           if (filters.from) {
             params.set('from', filters.from.toISOString())
           }
           if (filters.to) {
             params.set('to', filters.to.toISOString())
           }
           if (filters.search) {
             params.set('search', filters.search)
           }
           if (filters.levels.length) {
             params.set('levels', filters.levels.join(','))
           }

           const response = await fetch(
             `/api/environments/${environmentId}/logs?${params.toString()}`
           )
           if (!response.ok) {
             throw new Error('Failed to fetch logs')
           }

           const data = await response.json()
           setHistoricalLogs(data.logs || [])
         } catch (error) {
           console.error('Failed to fetch historical logs:', error)
           toast.error('Failed to load historical logs')
         } finally {
           setLoadingHistorical(false)
         }
       }

       fetchHistoricalLogs()
     }, [environmentId, filters.services, filters.from, filters.to, filters.search, filters.levels])

     // Combine historical and stream logs
     const allLogs = [...historicalLogs, ...streamLogs]

     // Apply client-side filtering
     const filteredLogs = allLogs.filter((log) => {
       // Filter by selected levels
       if (filters.levels.length && !filters.levels.includes(log.severity)) {
         return false
       }

       // Filter by search (if not using server-side search)
       if (filters.search) {
         if (filters.regexMode) {
           try {
             const regex = new RegExp(filters.search, 'i')
             return regex.test(log.message) || regex.test(log.serviceName)
           } catch {
             // Invalid regex, fallback to plain text
             return (
               log.message.toLowerCase().includes(filters.search.toLowerCase()) ||
               log.serviceName.toLowerCase().includes(filters.search.toLowerCase())
             )
           }
         } else {
           return (
             log.message.toLowerCase().includes(filters.search.toLowerCase()) ||
             log.serviceName.toLowerCase().includes(filters.search.toLowerCase())
           )
         }
       }

       return true
     })

     const handleToggleStreaming = () => {
       setFilters((prev) => ({ ...prev, streaming: !prev.streaming }))
     }

     return (
       <div className="space-y-4">
         {/* Status Bar */}
         <div className="flex items-center justify-between">
           <StreamStatus
             status={streamStatus}
             error={streamError}
             onRetry={connectStream}
           />
           <span className="text-sm text-muted-foreground">
             {filteredLogs.length} log entries
           </span>
         </div>

         {/* Filter Controls */}
         <LogFilterControls
           services={services}
           filters={filters}
           onFiltersChange={setFilters}
           streaming={filters.streaming}
           onToggleStreaming={handleToggleStreaming}
           environmentId={environmentId}
         />

         {/* Log Viewer */}
         <LogViewer
           logs={filteredLogs}
           loading={loadingHistorical}
           searchQuery={filters.search}
           autoScroll={filters.autoScroll}
           onToggleAutoScroll={() =>
             setFilters((prev) => ({ ...prev, autoScroll: !prev.autoScroll }))
           }
         />
       </div>
     )
   }
   ```

3. **Update Quick Actions Button**:
   - Modify "View Logs" button to switch to logs tab
   - Pass active tab state up if needed

4. **Responsive Design**:
   - Ensure tabs work on mobile (switch to accordion if needed)
   - Test log viewer on mobile viewport

5. **Testing**:
   - Integration tests for logs section
   - Test tab switching
   - Test filter persistence
   - Test streaming toggle

## Verification

- [ ] LogsSection component created
- [ ] Integrated into ProjectDetail component
- [ ] Tabs UI implemented (or alternative layout)
- [ ] Historical logs fetch on section open
- [ ] WebSocket streaming works when enabled
- [ ] Filters apply to both historical and stream logs
- [ ] "View Logs" quick action navigates to logs
- [ ] Responsive design works on mobile
- [ ] Clean up resources when switching environments
- [ ] Loading states display correctly
- [ ] Empty state shows when no logs
- [ ] Component follows existing styling patterns
- [ ] Tests added and passing

## Files Modified

- **New**: `web/src/components/logs/LogsSection.tsx`
- **New**: `web/src/components/logs/types.ts` (if not already created)
- **Modified**: `web/src/components/project/project-detail.tsx`

## Test Plan

### Integration Tests

```tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { ProjectDetail } from './project-detail'

// Mock API calls
jest.mock('@/hooks/useRailway', () => ({
  useRailwayProjectsDetails: () => ({
    data: mockProjects,
    isLoading: false,
  }),
  useEnvironmentServices: () => ({
    data: mockServices,
  }),
}))

describe('ProjectDetail - Logs Integration', () => {
  it('shows logs tab when environment selected', async () => {
    render(<ProjectDetail projectId="test-project" />)

    // Select an environment
    const envCard = screen.getByText('production')
    fireEvent.click(envCard)

    // Should see tabs
    await waitFor(() => {
      expect(screen.getByText('Logs')).toBeInTheDocument()
    })
  })

  it('loads logs when logs tab clicked', async () => {
    render(<ProjectDetail projectId="test-project" />)

    // Select environment and click logs tab
    fireEvent.click(screen.getByText('production'))
    fireEvent.click(screen.getByText('Logs'))

    // Should show loading then logs
    await waitFor(() => {
      expect(screen.getByText(/log entries/i)).toBeInTheDocument()
    })
  })

  it('disconnects WebSocket when switching tabs', async () => {
    render(<ProjectDetail projectId="test-project" />)

    fireEvent.click(screen.getByText('production'))
    fireEvent.click(screen.getByText('Logs'))

    // Wait for connection
    await waitFor(() => {
      expect(screen.getByText('Live')).toBeInTheDocument()
    })

    // Switch to Services tab
    fireEvent.click(screen.getByText('Services'))

    // Should disconnect (implementation detail, verify via mock)
  })
})
```

### Manual Testing Checklist
- [ ] Select environment and click Logs tab
- [ ] Verify historical logs load
- [ ] Verify streaming connects and shows "Live" status
- [ ] Apply filters and verify logs update
- [ ] Search logs and verify highlighting
- [ ] Export logs and verify download
- [ ] Toggle streaming off/on
- [ ] Switch between environments
- [ ] Switch between tabs (Services, Metadata, Logs)
- [ ] Verify "View Logs" quick action works
- [ ] Test on mobile viewport
- [ ] Verify cleanup on unmount (check DevTools for active connections)

### Success Criteria
- Logs section fully integrated and functional
- Historical and streaming logs work together
- Filters apply correctly
- UI matches existing app patterns
- No performance issues
- Tests pass


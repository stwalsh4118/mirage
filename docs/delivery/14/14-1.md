# [14-1] Research Railway GraphQL log API and create reference guide

[Back to task list](./tasks.md)

## Description

Research Railway's GraphQL API for log fetching to understand the available queries, parameters, response formats, pagination mechanisms, rate limits, and log retention policies. Create a comprehensive reference guide document to inform implementation decisions and avoid API hallucinations.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-04 00:00:00 | Created | N/A | Proposed | Task file created | ai-agent |
| 2025-10-05 00:00:00 | Status Update | Proposed | InProgress | Started research and guide creation | Sean |
| 2025-10-05 00:00:00 | Status Update | InProgress | Review | Completed comprehensive Railway Logs API guide with Go examples | Sean |
| 2025-10-05 00:00:00 | Status Update | Review | Done | Guide validated with live testing and Railway's actual implementation patterns | Sean |

## Requirements

1. **API Subscription Research**:
   - Document the `environmentLogs` subscription (environment-level, aggregates all services)
   - Document all subscription parameters:
     - `environmentId` (required)
     - `filter` (optional text filter)
     - Time-based pagination: `beforeDate`, `anchorDate`, `afterDate`, `beforeLimit`, `afterLimit`
   - Document response structure:
     - `timestamp`, `message`, `severity`
     - `tags` object (projectId, environmentId, serviceId, deploymentId, deploymentInstanceId, snapshotId)
     - `attributes` array (custom key-value pairs)
   - Determine WebSocket endpoint URL
   - Document subscription protocol (graphql-ws vs graphql-transport-ws)
   - Research other log-related operations: `deploymentLogs`, `buildLogs`, `events`

2. **Historical Log Query Research**:
   - Identify GraphQL query for fetching historical logs
   - Document pagination mechanism (cursor-based, offset-based, or limit-based)
   - Document filtering capabilities (time range, deployment ID, service, etc.)

3. **Filtering Capabilities**:
   - Time range filtering (from/to timestamps)
   - Deployment ID filtering
   - Service filtering capabilities
   - Log level/severity filtering (if supported)
   - Search/text filtering capabilities

4. **Rate Limits and Constraints**:
   - Document API rate limits for queries
   - Subscription connection limits (max concurrent subscriptions)
   - Identify reconnection requirements and backoff strategies
   - Document any throttling or backoff requirements

5. **WebSocket Connection Details**:
   - Authentication method for WebSocket connections
   - Connection initialization protocol
   - Heartbeat/ping requirements
   - Reconnection behavior and error handling

6. **Log Retention and Format**:
   - How far back does Railway retain logs?
   - What is the log line format (plain text, JSON, structured)?
   - Are timestamps included and in what format?
   - How are ANSI color codes handled?

7. **Reference Guide Creation**:
   - Create `14-railway-logs-api-guide.md` in the tasks directory
   - Include example subscription with variables (will go in `queries/subscriptions/deployment-logs.graphql`)
   - Include example query for historical logs (will go in `queries/queries/deployment-logs-history.graphql`)
   - Document expected responses with sample data
   - Include Go code snippets showing subscription setup using hasura client
   - Document how to structure `.graphql` files following task 14-0 pattern
   - Document WebSocket connection lifecycle
   - Date-stamp the guide and link to official Railway documentation

## Implementation Plan

1. **Web Research**:
   - Search for Railway GraphQL API log documentation
   - Check Railway's official API docs, GitHub, and community resources
   - Look for subscription examples in Railway CLI source code if available
   - Search for Railway WebSocket endpoint documentation

2. **API Exploration** (if API token available):
   - Use GraphQL introspection to explore the schema
   - Identify `deploymentLogs` subscription definition
   - Test subscription in GraphQL playground (if supports WebSocket)
   - Identify historical log query
   - Experiment with different parameters and filters
   - Document actual response structures

3. **WebSocket Protocol Investigation**:
   - Determine which protocol Railway uses (graphql-ws or graphql-transport-ws)
   - Document connection initialization sequence
   - Document authentication method for subscriptions
   - Test connection establishment and message format

4. **Documentation Synthesis**:
   - Consolidate findings into structured guide document
   - Document the actual `environmentLogs` subscription:
     ```graphql
     subscription StreamEnvironmentLogs(
       $environmentId: String!
       $filter: String
       $beforeLimit: Int!
       $beforeDate: String
       $anchorDate: String
       $afterDate: String
       $afterLimit: Int
     ) {
       environmentLogs(
         environmentId: $environmentId
         filter: $filter
         beforeDate: $beforeDate
         anchorDate: $anchorDate
         afterDate: $afterDate
         beforeLimit: $beforeLimit
         afterLimit: $afterLimit
       ) {
         timestamp
         message
         severity
         tags {
           projectId
           environmentId
           serviceId
           deploymentId
           deploymentInstanceId
           snapshotId
         }
         attributes {
           key
           value
         }
       }
     }
     ```
   - Document other log operations (deploymentLogs, buildLogs, events)
   - Document Go code patterns using hasura/go-graphql-client for subscriptions
   - Document hybrid approach: machinebox/graphql for queries, hasura for subscriptions
   - Explain pagination strategy (anchor-based with before/after limits)

5. **Validation**:
   - Verify subscription schema is correct
   - Test subscription connection and message flow
   - Test historical query with pagination
   - Confirm rate limits and connection limits through testing or documentation

## Verification

- [x] Reference guide document created at `docs/delivery/14/14-railway-logs-api-guide.md`
- [x] Document includes example GraphQL subscription with variables
- [x] Document includes example query for historical logs
- [x] Document includes sample response structures
- [x] WebSocket endpoint URL documented
- [x] Subscription protocol (graphql-ws/graphql-transport-ws) identified
- [x] Authentication method for subscriptions documented
- [x] Rate limits and connection limits documented
- [x] Log retention policy is documented
- [x] Document is date-stamped and links to official Railway docs
- [x] Document includes Go code snippets for subscription setup using hasura/go-graphql-client
- [x] Document explains hybrid approach (machinebox for queries, hasura for subscriptions)
- [x] All subscription and query schemas validated (either through testing or official docs)

## Files Modified

- **New**: `docs/delivery/14/14-railway-logs-api-guide.md`

## Important Findings

### WebSocket Endpoint Discovery

**Observed Endpoint:** `wss://backboard.railway.app/graphql/internal`

**Source:** Railway sidecar tooling (designed to run as a Railway service)

**Key Concerns:**
1. The `/internal` path suggests this endpoint may be designed for internal Railway service communication (service-to-service within Railway's infrastructure)
2. **Unknown:** Whether this endpoint is accessible from external clients (outside Railway's network)
3. The guide now includes contingency plans if external access is restricted

**Action Required for Task 14-2:**
Before implementing the full log subscription client, we need to test external connectivity to this endpoint:

```bash
# Test from external client
wscat -c wss://backboard.railway.app/graphql/internal \
  -H "Authorization: Bearer $RAILWAY_TOKEN"
```

**Test Results (2025-10-05):**

✅ **SUCCESS - External Access Confirmed!**

1. **Connection Test:** Using `wscat` with proper subprotocol
   ```bash
   wscat -c wss://backboard.railway.app/graphql/internal \
     -H "Authorization: Bearer $RAILWAY_TOKEN" \
     -s graphql-transport-ws
   ```

2. **Findings:**
   - ✅ WebSocket connection establishes successfully from external client
   - ✅ Authentication with Bearer token works
   - ✅ Server accepts `graphql-transport-ws` subprotocol
   - ⚠️ **Critical:** Subprotocol MUST be specified or connection fails with `code: 4406, reason: "Subprotocol not acceptable"`
   - Server properly waits for GraphQL WebSocket handshake (`connection_init` message)

3. **Conclusion:** 
   - The `/graphql/internal` endpoint is accessible from external clients
   - No proxy service or alternative approach needed
   - **Task 14-2 can proceed as originally planned**

### Railway's Actual Implementation (From Sidecar Source)

**Key Discovery:** Found Railway's reference implementation in their sidecar tooling, providing the exact pattern they use:

**Libraries:**
- `github.com/coder/websocket` (minimal and idiomatic WebSocket library)
- `github.com/gofrs/uuid` for subscription IDs

**Connection Pattern:**
1. Set `Subprotocols: []string{"graphql-transport-ws"}` in DialOptions
2. Set `conn.SetReadLimit(-1)` to handle large log batches
3. Three-step handshake:
   - Send `{"type":"connection_init"}`
   - Wait for `{"type":"connection_ack"}`
   - Send subscription payload with `id`, `type: "subscribe"`, and `payload`

**Subscription Variables:**
```go
{
    EnvironmentID: uuid,
    Filter: serviceFilter,
    BeforeDate: time.Now().UTC().Add(-5 * time.Minute).Format(time.RFC3339Nano),
    BeforeLimit: 500,
}
```

**Why This Matters:**
- Provides "seamless subscription resuming" by fetching last 5 minutes of logs
- Avoids missing logs during brief disconnections
- Sets reasonable limit of 500 logs for initial backfill

**Impact on Task 14-2:**
- Use Railway's exact pattern (documented in guide)
- No guesswork - we have their production implementation
- Higher confidence in implementation correctness

**Domain Correction:**
All endpoints corrected from `backboard.railway.com` to `backboard.railway.app`

## Test Plan

This is a research and documentation task. Testing consists of:
1. Validating that documented queries are syntactically correct GraphQL
2. If API access available, executing queries to verify response structures match documentation
3. Peer review of the guide for completeness and accuracy


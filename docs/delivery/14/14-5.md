# [14-5] Implement WebSocket endpoint for real-time log streaming

[Back to task list](./tasks.md)

## Description

Create a WebSocket endpoint to stream logs in real-time to connected frontend clients. This endpoint subscribes to Railway's GraphQL log subscription and relays the received logs to connected WebSocket clients, enabling live log monitoring in the UI. This is a relay architecture: Railway subscription → Backend WebSocket → Frontend clients.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-04 00:00:00 | Created | N/A | Proposed | Task file created | ai-agent |

## Requirements

1. **WebSocket Endpoint**:
   - Create WS `/api/environments/:id/logs/stream` endpoint
   - Support query parameters for filtering (services, search)
   - Maintain persistent connection for streaming
   - Handle multiple concurrent client connections

2. **Subscription Relay Strategy**:
   - Subscribe to Railway's GraphQL subscription when client connects
   - Relay logs from Railway subscription to frontend client in real-time
   - No polling needed - Railway pushes logs via WebSocket
   - Handle Railway subscription errors and reconnection

3. **Message Protocol**:
   - Send log entries as JSON messages: `{"type": "log", "data": {...}}`
   - Send heartbeat/ping messages to keep connection alive
   - Send error messages: `{"type": "error", "message": "..."}`
   - Send status messages: `{"type": "status", "message": "connected"}`

4. **Connection Management**:
   - Gracefully handle client disconnections
   - Clean up polling goroutines on disconnect
   - Support reconnection (client must include `lastTimestamp` query param)
   - Limit maximum connections per environment (e.g., 10)

5. **Performance and Resource Management**:
   - Use goroutine pool for polling
   - Implement context-based cancellation
   - Prevent memory leaks from long-running connections
   - Rate limit polling to respect Railway API limits

## Implementation Plan

1. **WebSocket Handler** in `api/internal/controller/logs.go`:
   ```go
   import "github.com/gorilla/websocket"

   const (
       defaultPollInterval = 3 * time.Second
       maxConnectionsPerEnv = 10
       writeWait = 10 * time.Second
       pongWait = 60 * time.Second
       pingPeriod = (pongWait * 9) / 10
   )

   var upgrader = websocket.Upgrader{
       CheckOrigin: func(r *http.Request) bool {
           // Validate origin against allowed origins from config
           return true
       },
   }

   func (c *LogsController) StreamEnvironmentLogs(ctx *gin.Context) {
       // Upgrade HTTP connection to WebSocket
       // Parse environment ID and query params
       // Start polling goroutine
       // Handle messages and errors
   }
   ```

2. **Client Connection Manager**:
   ```go
   type logStreamClient struct {
       environmentID string
       conn          *websocket.Conn
       send          chan []byte
       filters       LogFilters
       cancel        context.CancelFunc
       railwayCancel context.CancelFunc
   }

   func (c *logStreamClient) readPump() {
       // Read messages from client (pings, filter updates)
   }

   func (c *logStreamClient) writePump() {
       // Write messages to client from send channel
       // Send periodic pings
   }

   func (c *logStreamClient) subscribeToRailwayLogs(railway *railway.Client, deploymentID string) {
       // Subscribe to Railway's GraphQL subscription
       // Relay logs from subscription channel to client send channel
   }
   ```

3. **Implement Streaming Logic**:
   - Upgrade HTTP connection to WebSocket
   - Create client struct and start read/write pumps
   - Subscribe to Railway's log subscription (from task 14-2)
   - Create channel to receive logs from Railway subscription
   - Relay logs from Railway channel to client WebSocket
   - Filter logs based on client filters before sending
   - Handle disconnection and cleanup
   
   **Example flow:**
   ```go
   func (c *LogsController) StreamEnvironmentLogs(ctx *gin.Context) {
       // Upgrade to WebSocket
       conn, _ := upgrader.Upgrade(ctx.Writer, ctx.Request, nil)
       defer conn.Close()
       
       // Get deployment ID for environment
       deploymentID := getDeploymentIDForEnvironment(environmentID)
       
       // Create channel to receive logs from Railway
       logChan := make(chan railway.DeploymentLog, 100)
       
       // Subscribe to Railway in goroutine
       railwayCtx, railwayCancel := context.WithCancel(ctx)
       defer railwayCancel()
       
       go func() {
           if err := c.Railway.SubscribeToDeploymentLogs(railwayCtx, deploymentID, logChan); err != nil {
               log.Error().Err(err).Msg("Railway subscription failed")
           }
       }()
       
       // Relay logs from Railway to WebSocket client
       for {
           select {
           case log := <-logChan:
               // Filter if needed
               // Format as JSON
               // Send to WebSocket client
               conn.WriteJSON(map[string]interface{}{
                   "type": "log",
                   "data": log,
               })
           case <-ctx.Done():
               return
           }
       }
   }
   ```

4. **Error Handling and Reconnection**:
   - Send error messages on Railway subscription failures
   - Railway subscription client (hasura) handles automatic reconnection
   - If Railway subscription fails permanently, notify WebSocket client
   - Support frontend client reconnection (handled by client-side logic)
   - Log connection events for monitoring

5. **Register WebSocket Route**:
   - Add route in `RegisterRoutes`: `r.GET("/environments/:id/logs/stream", c.StreamEnvironmentLogs)`
   - Ensure WebSocket upgrade works with Gin middleware

6. **Dependencies**:
   - Add `github.com/gorilla/websocket` to go.mod (if not already present)
   - Update CORS config to allow WebSocket connections
   - Requires task 14-2 completed (Railway subscription functions available)

7. **Testing**:
   - Unit tests for message formatting
   - Integration test with WebSocket client
   - Test connection lifecycle (connect, stream, disconnect)
   - Test error handling and recovery

## Verification

- [ ] WebSocket endpoint `/api/environments/:id/logs/stream` implemented
- [ ] Connection upgrade from HTTP to WebSocket works
- [ ] Railway subscription established when client connects
- [ ] Logs relayed from Railway subscription to WebSocket client
- [ ] Log messages sent to client in JSON format
- [ ] Heartbeat/ping messages keep connection alive
- [ ] Client disconnection properly cleans up resources
- [ ] Reconnection with `lastTimestamp` avoids duplicates
- [ ] Error handling sends appropriate messages to client
- [ ] Multiple concurrent clients can stream from same environment
- [ ] Gorilla WebSocket dependency added to go.mod
- [ ] Tests verify connection lifecycle
- [ ] No memory leaks or goroutine leaks
- [ ] CORS configured for WebSocket

## Files Modified

- **Modified**: `api/internal/controller/logs.go` (add WebSocket handler)
- **Modified**: `api/internal/controller/logs_test.go` (add WebSocket tests)
- **Modified**: `go.mod` (add gorilla/websocket dependency)
- **Modified**: `api/internal/server/server.go` (ensure CORS allows WebSocket)

## Test Plan

### Unit Tests

```go
func TestStreamMessage_Format(t *testing.T) {
    log := logutil.ParsedLog{
        Timestamp: time.Now(),
        Severity: logutil.SeverityInfo,
        Message: "test message",
        ServiceName: "api",
    }
    
    msg := formatStreamMessage("log", log)
    var parsed map[string]interface{}
    json.Unmarshal(msg, &parsed)
    
    assert.Equal(t, "log", parsed["type"])
    assert.NotNil(t, parsed["data"])
}
```

### Integration Tests

```go
func TestWebSocket_StreamLogs(t *testing.T) {
    // Setup test server with logs controller
    server := httptest.NewServer(setupTestRouter())
    defer server.Close()
    
    // Convert http:// to ws://
    wsURL := "ws" + strings.TrimPrefix(server.URL, "http") + "/api/environments/test-id/logs/stream"
    
    // Connect WebSocket client
    ws, _, err := websocket.DefaultDialer.Dial(wsURL, nil)
    require.NoError(t, err)
    defer ws.Close()
    
    // Read first message (should be status:connected)
    var msg map[string]interface{}
    err = ws.ReadJSON(&msg)
    require.NoError(t, err)
    assert.Equal(t, "status", msg["type"])
    
    // Wait for log messages or timeout
    done := make(chan bool)
    go func() {
        for {
            var logMsg map[string]interface{}
            if err := ws.ReadJSON(&logMsg); err != nil {
                return
            }
            if logMsg["type"] == "log" {
                done <- true
                return
            }
        }
    }()
    
    select {
    case <-done:
        // Success
    case <-time.After(10 * time.Second):
        t.Fatal("timeout waiting for log message")
    }
}

func TestWebSocket_Reconnection(t *testing.T) {
    // Test that reconnecting with lastTimestamp doesn't receive duplicates
}

func TestWebSocket_Cleanup(t *testing.T) {
    // Verify goroutines are cleaned up after disconnect
    before := runtime.NumGoroutine()
    
    // Connect and disconnect multiple clients
    // ...
    
    time.Sleep(100 * time.Millisecond)
    after := runtime.NumGoroutine()
    assert.LessOrEqual(t, after, before+2) // Allow small variance
}
```

### Manual Testing Checklist
- [ ] Connect to WebSocket endpoint using browser DevTools or wscat
- [ ] Verify receiving log messages in real-time
- [ ] Verify heartbeat/ping messages received
- [ ] Test disconnection and reconnection
- [ ] Test multiple concurrent clients
- [ ] Verify cleanup on client disconnect (check goroutine count)
- [ ] Test filtering via query parameters
- [ ] Test error handling (e.g., invalid environment ID)

### Success Criteria
- WebSocket connection established successfully
- Log messages stream in real-time
- No memory or goroutine leaks after disconnect
- Multiple clients can connect concurrently
- Error handling graceful and informative


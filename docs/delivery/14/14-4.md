# [14-4] Create HTTP API endpoints for log retrieval and export

[Back to task list](./tasks.md)

## Description

Implement REST API endpoints in the environment controller to fetch and export logs. These endpoints will use the Railway client log functions and logutil package to serve aggregated, filtered, and formatted logs to the frontend.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-04 00:00:00 | Created | N/A | Proposed | Task file created | ai-agent |

## Requirements

1. **GET /api/environments/:id/logs**:
   - Fetch aggregated logs for all services in an environment
   - Support query parameters: `services` (comma-separated), `from` (timestamp), `to` (timestamp), `limit` (int), `search` (string)
   - Return JSON array of parsed log entries
   - Include pagination metadata (next cursor, has more)

2. **GET /api/services/:id/logs**:
   - Fetch logs for a specific service
   - Support same query parameters as environment endpoint
   - Return JSON array of parsed log entries

3. **GET /api/logs/export**:
   - Export logs in specified format (JSON, CSV, TXT)
   - Require `environmentId` or `serviceId` query parameter
   - Support `format` query parameter (default: JSON)
   - Set appropriate Content-Type and Content-Disposition headers
   - Generate filename: `{environment-name}-logs-{timestamp}.{ext}`

4. **Error Handling**:
   - Return 400 for invalid query parameters
   - Return 404 for non-existent environment/service
   - Return 503 if Railway client unavailable
   - Return 502 for Railway API errors
   - Include meaningful error messages

5. **Performance Considerations**:
   - Set reasonable default/maximum limits (e.g., 1000 lines)
   - Implement timeout for Railway API calls
   - Log slow queries for monitoring

## Implementation Plan

1. **Add Endpoints to Controller** in `api/internal/controller/logs.go`:
   ```go
   type LogsController struct {
       DB      *gorm.DB
       Railway *railway.Client
   }

   func (c *LogsController) RegisterRoutes(r *gin.RouterGroup) {
       r.GET("/environments/:id/logs", c.GetEnvironmentLogs)
       r.GET("/services/:id/logs", c.GetServiceLogs)
       r.GET("/logs/export", c.ExportLogs)
   }
   ```

2. **Implement GetEnvironmentLogs**:
   - Extract and validate query parameters
   - Look up environment in database to get associated services
   - For each service, fetch logs from Railway API
   - Use `logutil.LogAggregator` to merge logs chronologically
   - Parse and enrich logs with service names
   - Apply search filter if provided
   - Return JSON response with logs and pagination metadata

3. **Implement GetServiceLogs**:
   - Similar to GetEnvironmentLogs but for single service
   - Validate service ID and fetch Railway service/deployment ID
   - Fetch logs from Railway API
   - Parse and return logs

4. **Implement ExportLogs**:
   - Extract environmentId or serviceId from query params
   - Fetch logs using appropriate method
   - Apply filters (services, time range, search)
   - Format logs using `logutil.Format*` functions
   - Set Content-Type based on format:
     - `application/json` for JSON
     - `text/csv` for CSV
     - `text/plain` for TXT
   - Set Content-Disposition header with generated filename
   - Return formatted byte stream

5. **Register Routes** in `api/internal/server/server.go`:
   - Add LogsController initialization
   - Register routes under `/api` group

6. **Testing**:
   - Add controller tests with mocked Railway client
   - Test query parameter validation
   - Test pagination logic
   - Test export format generation
   - Integration test with real Railway API (if token available)

## Verification

- [ ] `logs.go` controller file created
- [ ] `LogsController` struct defined with DB and Railway client
- [ ] GET `/api/environments/:id/logs` endpoint implemented
- [ ] GET `/api/services/:id/logs` endpoint implemented
- [ ] GET `/api/logs/export` endpoint implemented
- [ ] Query parameter validation works correctly
- [ ] Logs are aggregated chronologically across services
- [ ] Search filtering works for text matching
- [ ] Export formats (JSON, CSV, TXT) generate correctly
- [ ] Error handling returns appropriate HTTP status codes
- [ ] Routes registered in server.go
- [ ] Controller tests added with >70% coverage
- [ ] No linter errors
- [ ] Code follows existing controller patterns

## Files Modified

- **New**: `api/internal/controller/logs.go`
- **New**: `api/internal/controller/logs_test.go`
- **Modified**: `api/internal/server/server.go` (register routes)

## Test Plan

### Unit Tests

```go
func TestGetEnvironmentLogs_Success(t *testing.T) {
    // Mock Railway client
    mockRailway := &MockRailwayClient{
        GetDeploymentLogsFunc: func(ctx context.Context, input railway.GetDeploymentLogsInput) (railway.GetDeploymentLogsResult, error) {
            return railway.GetDeploymentLogsResult{
                Logs: []railway.DeploymentLog{
                    {Timestamp: time.Now(), Message: "test log", ServiceName: "api"},
                },
                HasMore: false,
            }, nil
        },
    }
    
    // Create controller with mock
    controller := &LogsController{Railway: mockRailway, DB: setupTestDB()}
    
    // Create test environment with services
    // ...
    
    // Create test request
    req := httptest.NewRequest("GET", "/api/environments/test-env-id/logs?limit=100", nil)
    w := httptest.NewRecorder()
    
    // Execute
    controller.GetEnvironmentLogs(gin context from req)
    
    // Assert
    assert.Equal(t, http.StatusOK, w.Code)
    var response struct {
        Logs []map[string]interface{} `json:"logs"`
    }
    json.Unmarshal(w.Body.Bytes(), &response)
    assert.Len(t, response.Logs, 1)
}

func TestGetEnvironmentLogs_InvalidParameters(t *testing.T) {
    controller := &LogsController{Railway: nil, DB: nil}
    
    // Test invalid limit
    req := httptest.NewRequest("GET", "/api/environments/test-env-id/logs?limit=abc", nil)
    w := httptest.NewRecorder()
    controller.GetEnvironmentLogs(gin context)
    
    assert.Equal(t, http.StatusBadRequest, w.Code)
}

func TestExportLogs_CSV(t *testing.T) {
    // Setup mock controller with test data
    // ...
    
    req := httptest.NewRequest("GET", "/api/logs/export?environmentId=test&format=csv", nil)
    w := httptest.NewRecorder()
    
    controller.ExportLogs(gin context)
    
    assert.Equal(t, http.StatusOK, w.Code)
    assert.Equal(t, "text/csv", w.Header().Get("Content-Type"))
    assert.Contains(t, w.Header().Get("Content-Disposition"), ".csv")
    assert.Contains(t, w.Body.String(), "Timestamp,Service,Level,Message")
}
```

### Integration Tests

```go
func TestIntegration_GetEnvironmentLogs(t *testing.T) {
    token := os.Getenv("RAILWAY_API_TOKEN")
    envID := os.Getenv("TEST_ENVIRONMENT_ID")
    if token == "" || envID == "" {
        t.Skip("credentials not set")
    }
    
    // Setup real controller with Railway client
    // Make real HTTP request
    // Verify response structure
}
```

### Manual Testing Checklist
- [ ] GET `/api/environments/:id/logs` returns logs
- [ ] Query parameter `limit` works correctly
- [ ] Query parameter `search` filters logs
- [ ] Query parameter `from`/`to` filters by time range
- [ ] Export endpoint returns CSV with correct headers
- [ ] Export endpoint returns JSON with proper structure
- [ ] Export endpoint returns plain text formatted nicely
- [ ] Error cases return appropriate status codes
- [ ] Large log volumes don't cause timeout

### Success Criteria
- All unit tests pass
- Integration tests pass (when credentials available)
- Endpoints return correct response structure
- Export generates valid formats
- No performance degradation with 1000+ log lines


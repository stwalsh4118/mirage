# [14-8] Add WebSocket client and real-time streaming logic

[Back to task list](./tasks.md)

## Description

Implement the frontend WebSocket client logic to connect to the backend WebSocket endpoint, receive real-time log messages, handle reconnection, and manage the log buffer. This provides the live log streaming capability.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-04 00:00:00 | Created | N/A | Proposed | Task file created | ai-agent |

## Requirements

1. **WebSocket Connection**:
   - Create custom hook `useLogStream` for managing WebSocket connection
   - Connect to `ws://[host]/api/environments/:id/logs/stream`
   - Support filter query parameters in connection URL
   - Handle connection states: connecting, connected, disconnected, error

2. **Message Handling**:
   - Parse incoming JSON messages
   - Handle different message types: log, error, status, ping
   - Append new log entries to existing logs array
   - Trigger re-render when new logs arrive

3. **Reconnection Logic**:
   - Implement exponential backoff for reconnection attempts
   - Track last received timestamp to avoid duplicates on reconnect
   - Maximum reconnection attempts (e.g., 5 times)
   - Show reconnection status to user

4. **Buffer Management**:
   - Limit in-memory log buffer (e.g., last 5000 lines)
   - Implement circular buffer to prevent memory overflow
   - Remove old logs when limit reached (FIFO)

5. **Connection Lifecycle**:
   - Connect when component mounts or streaming enabled
   - Disconnect when component unmounts or streaming paused
   - Clean up resources on unmount
   - Handle page visibility changes (pause when hidden)

6. **Error Handling**:
   - Handle connection errors gracefully
   - Display error messages to user
   - Provide retry button
   - Log errors for debugging

## Implementation Plan

1. **Create WebSocket Hook** in `web/src/hooks/useLogStream.ts`:
   ```tsx
   import { useEffect, useRef, useState, useCallback } from 'react'

   interface LogStreamOptions {
     environmentId: string
     filters?: {
       services?: string[]
       search?: string
       levels?: string[]
     }
     enabled?: boolean
     maxBufferSize?: number
   }

   interface LogStreamResult {
     logs: Log[]
     status: 'connecting' | 'connected' | 'disconnected' | 'error'
     error: string | null
     connect: () => void
     disconnect: () => void
     clear: () => void
   }

   export function useLogStream(options: LogStreamOptions): LogStreamResult {
     const [logs, setLogs] = useState<Log[]>([])
     const [status, setStatus] = useState<'connecting' | 'connected' | 'disconnected' | 'error'>('disconnected')
     const [error, setError] = useState<string | null>(null)
     
     const wsRef = useRef<WebSocket | null>(null)
     const reconnectAttemptsRef = useRef(0)
     const lastTimestampRef = useRef<string | null>(null)
     const maxBufferSize = options.maxBufferSize || 5000

     const buildWebSocketUrl = useCallback(() => {
       const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
       const host = window.location.host
       let url = `${protocol}//${host}/api/environments/${options.environmentId}/logs/stream`
       
       const params = new URLSearchParams()
       if (options.filters?.services?.length) {
         params.set('services', options.filters.services.join(','))
       }
       if (options.filters?.search) {
         params.set('search', options.filters.search)
       }
       if (options.filters?.levels?.length) {
         params.set('levels', options.filters.levels.join(','))
       }
       if (lastTimestampRef.current) {
         params.set('lastTimestamp', lastTimestampRef.current)
       }
       
       const queryString = params.toString()
       if (queryString) {
         url += `?${queryString}`
       }
       
       return url
     }, [options.environmentId, options.filters])

     const connect = useCallback(() => {
       if (wsRef.current?.readyState === WebSocket.OPEN) {
         return
       }

       setStatus('connecting')
       setError(null)

       try {
         const ws = new WebSocket(buildWebSocketUrl())
         wsRef.current = ws

         ws.onopen = () => {
           console.log('WebSocket connected')
           setStatus('connected')
           reconnectAttemptsRef.current = 0
         }

         ws.onmessage = (event) => {
           try {
             const message = JSON.parse(event.data)

             switch (message.type) {
               case 'log':
                 setLogs((prevLogs) => {
                   const newLog = message.data
                   lastTimestampRef.current = newLog.timestamp

                   // Circular buffer: remove old logs if exceeding limit
                   const updatedLogs = [...prevLogs, newLog]
                   if (updatedLogs.length > maxBufferSize) {
                     return updatedLogs.slice(-maxBufferSize)
                   }
                   return updatedLogs
                 })
                 break

               case 'error':
                 console.error('Stream error:', message.message)
                 setError(message.message)
                 break

               case 'status':
                 console.log('Stream status:', message.message)
                 break

               case 'ping':
                 // Heartbeat - no action needed
                 break

               default:
                 console.warn('Unknown message type:', message.type)
             }
           } catch (err) {
             console.error('Failed to parse message:', err)
           }
         }

         ws.onerror = (event) => {
           console.error('WebSocket error:', event)
           setStatus('error')
           setError('Connection error occurred')
         }

         ws.onclose = (event) => {
           console.log('WebSocket closed:', event.code, event.reason)
           setStatus('disconnected')
           wsRef.current = null

           // Attempt reconnection with exponential backoff
           if (reconnectAttemptsRef.current < 5 && options.enabled !== false) {
             const delay = Math.min(1000 * Math.pow(2, reconnectAttemptsRef.current), 30000)
             reconnectAttemptsRef.current++
             console.log(`Reconnecting in ${delay}ms (attempt ${reconnectAttemptsRef.current})`)
             setTimeout(connect, delay)
           }
         }
       } catch (err) {
         console.error('Failed to create WebSocket:', err)
         setStatus('error')
         setError('Failed to connect to log stream')
       }
     }, [buildWebSocketUrl, options.enabled, maxBufferSize])

     const disconnect = useCallback(() => {
       if (wsRef.current) {
         wsRef.current.close()
         wsRef.current = null
       }
       setStatus('disconnected')
       reconnectAttemptsRef.current = 0
     }, [])

     const clear = useCallback(() => {
       setLogs([])
       lastTimestampRef.current = null
     }, [])

     // Connect/disconnect based on enabled flag
     useEffect(() => {
       if (options.enabled) {
         connect()
       } else {
         disconnect()
       }

       return () => {
         disconnect()
       }
     }, [options.enabled, connect, disconnect])

     // Handle page visibility changes
     useEffect(() => {
       const handleVisibilityChange = () => {
         if (document.hidden) {
           disconnect()
         } else if (options.enabled) {
           connect()
         }
       }

       document.addEventListener('visibilitychange', handleVisibilityChange)
       return () => {
         document.removeEventListener('visibilitychange', handleVisibilityChange)
       }
     }, [options.enabled, connect, disconnect])

     return {
       logs,
       status,
       error,
       connect,
       disconnect,
       clear,
     }
   }
   ```

2. **Connection Status Indicator** in `web/src/components/logs/StreamStatus.tsx`:
   ```tsx
   interface StreamStatusProps {
     status: 'connecting' | 'connected' | 'disconnected' | 'error'
     error?: string | null
     onRetry?: () => void
   }

   export function StreamStatus({ status, error, onRetry }: StreamStatusProps) {
     const statusConfig = {
       connecting: {
         icon: 'ðŸ”„',
         text: 'Connecting...',
         className: 'text-yellow-600',
       },
       connected: {
         icon: 'ðŸŸ¢',
         text: 'Live',
         className: 'text-green-600',
       },
       disconnected: {
         icon: 'âšª',
         text: 'Disconnected',
         className: 'text-gray-600',
       },
       error: {
         icon: 'ðŸ”´',
         text: error || 'Error',
         className: 'text-red-600',
       },
     }

     const config = statusConfig[status]

     return (
       <div className="flex items-center gap-2">
         <span className={config.className}>
           {config.icon} {config.text}
         </span>
         {status === 'error' && onRetry && (
           <Button variant="outline" size="sm" onClick={onRetry}>
             Retry
           </Button>
         )}
       </div>
     )
   }
   ```

3. **Testing**:
   - Mock WebSocket for unit tests
   - Test connection lifecycle
   - Test message handling
   - Test reconnection logic
   - Test buffer management

## Verification

- [ ] `useLogStream` hook created
- [ ] WebSocket connection establishes successfully
- [ ] Log messages received and parsed correctly
- [ ] Buffer management prevents memory overflow
- [ ] Reconnection works with exponential backoff
- [ ] Connection status tracked accurately
- [ ] Disconnection cleans up resources
- [ ] Page visibility changes handled
- [ ] Error messages displayed to user
- [ ] StreamStatus component shows connection state
- [ ] Tests added and passing
- [ ] No memory leaks

## Files Modified

- **New**: `web/src/hooks/useLogStream.ts`
- **New**: `web/src/hooks/useLogStream.test.ts`
- **New**: `web/src/components/logs/StreamStatus.tsx`

## Test Plan

### Hook Tests

```tsx
import { renderHook, act, waitFor } from '@testing-library/react'
import { useLogStream } from './useLogStream'

// Mock WebSocket
class MockWebSocket {
  static instances: MockWebSocket[] = []
  
  onopen: (() => void) | null = null
  onmessage: ((event: any) => void) | null = null
  onerror: ((event: any) => void) | null = null
  onclose: ((event: any) => void) | null = null
  readyState: number = WebSocket.CONNECTING

  constructor(public url: string) {
    MockWebSocket.instances.push(this)
  }

  close() {
    this.readyState = WebSocket.CLOSED
    this.onclose?.({ code: 1000, reason: 'Normal closure' })
  }

  send(data: string) {
    // Mock send
  }
}

global.WebSocket = MockWebSocket as any

describe('useLogStream', () => {
  afterEach(() => {
    MockWebSocket.instances = []
  })

  it('connects when enabled', async () => {
    const { result } = renderHook(() =>
      useLogStream({
        environmentId: 'test-env',
        enabled: true,
      })
    )

    expect(result.current.status).toBe('connecting')

    // Simulate connection open
    act(() => {
      const ws = MockWebSocket.instances[0]
      ws.readyState = WebSocket.OPEN
      ws.onopen?.()
    })

    await waitFor(() => {
      expect(result.current.status).toBe('connected')
    })
  })

  it('receives and appends log messages', async () => {
    const { result } = renderHook(() =>
      useLogStream({
        environmentId: 'test-env',
        enabled: true,
      })
    )

    // Simulate connection and message
    act(() => {
      const ws = MockWebSocket.instances[0]
      ws.readyState = WebSocket.OPEN
      ws.onopen?.()

      ws.onmessage?.({
        data: JSON.stringify({
          type: 'log',
          data: {
            timestamp: '2024-01-01T12:00:00Z',
            severity: 'INFO',
            message: 'Test log',
            serviceName: 'api',
          },
        }),
      })
    })

    await waitFor(() => {
      expect(result.current.logs).toHaveLength(1)
      expect(result.current.logs[0].message).toBe('Test log')
    })
  })

  it('limits buffer size', async () => {
    const { result } = renderHook(() =>
      useLogStream({
        environmentId: 'test-env',
        enabled: true,
        maxBufferSize: 3,
      })
    )

    act(() => {
      const ws = MockWebSocket.instances[0]
      ws.readyState = WebSocket.OPEN
      ws.onopen?.()

      // Send 5 log messages
      for (let i = 0; i < 5; i++) {
        ws.onmessage?.({
          data: JSON.stringify({
            type: 'log',
            data: {
              timestamp: new Date().toISOString(),
              message: `Log ${i}`,
              serviceName: 'api',
            },
          }),
        })
      }
    })

    await waitFor(() => {
      // Should only keep last 3 logs
      expect(result.current.logs).toHaveLength(3)
      expect(result.current.logs[0].message).toBe('Log 2')
      expect(result.current.logs[2].message).toBe('Log 4')
    })
  })

  it('disconnects on unmount', () => {
    const { result, unmount } = renderHook(() =>
      useLogStream({
        environmentId: 'test-env',
        enabled: true,
      })
    )

    const ws = MockWebSocket.instances[0]
    const closeSpy = jest.spyOn(ws, 'close')

    unmount()

    expect(closeSpy).toHaveBeenCalled()
  })
})
```

### Manual Testing Checklist
- [ ] WebSocket connects successfully
- [ ] Live logs appear in real-time
- [ ] Reconnection works after network interruption
- [ ] Buffer limits work (test with high log volume)
- [ ] Disconnection on page hide
- [ ] Reconnection on page show
- [ ] Error state displays correctly
- [ ] Retry button works
- [ ] Clean disconnect on component unmount

### Success Criteria
- WebSocket connection stable
- Messages handled correctly
- Reconnection reliable
- No memory leaks
- Tests pass


# [14-0] Refactor GraphQL queries to separate .graphql files with embed

[Back to task list](./tasks.md)

## Description

Refactor existing inline GraphQL query strings in the Railway client to use separate `.graphql` files that are embedded at compile time using Go's `embed` package. This establishes a clean pattern for GraphQL operations that will be followed when adding log queries and subscriptions in subsequent tasks.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-04 00:00:00 | Created | N/A | Proposed | Task file created | ai-agent |
| 2025-10-05 00:00:00 | Status Update | Proposed | Done | Refactored GraphQL queries to separate files with embed pattern | Sean |

## Requirements

1. **Create GraphQL Files Directory**:
   - Create `api/internal/railway/queries/` directory
   - Organize by operation type: `queries/`, `mutations/`, `subscriptions/` subdirectories
   - Name files descriptively (e.g., `project-by-id.graphql`, `list-projects.graphql`)

2. **Extract Existing Queries**:
   - Move all query strings from `projects.go`, `service.go`, `env.go` to separate files
   - Maintain exact same query content (no functional changes)
   - Keep query variables and structure identical

3. **Implement Embed Pattern**:
   - Use `//go:embed` directive to embed `.graphql` files
   - Create package-level variables for each query
   - Maintain existing naming conventions

4. **Update Client Code**:
   - Replace inline query strings with embedded variables
   - Ensure all existing functionality works unchanged
   - No changes to function signatures or behavior

5. **Documentation**:
   - Add README in `queries/` directory explaining the pattern
   - Document naming conventions for new queries

## Implementation Plan

1. **Create Directory Structure**:
   ```
   api/internal/railway/
   ├── client.go
   ├── projects.go
   ├── service.go
   ├── env.go
   ├── logs.go (will be added in 14-2)
   └── queries/
       ├── README.md
       ├── queries/
       │   ├── project-by-id.graphql
       │   ├── project-details-by-id.graphql
       │   ├── list-projects-root.graphql
       │   ├── projects-details-root.graphql
       │   └── environment-by-id.graphql
       ├── mutations/
       │   ├── project-create.graphql
       │   ├── project-destroy.graphql
       │   ├── service-create.graphql
       │   ├── service-delete.graphql
       │   ├── environment-create.graphql
       │   └── environment-delete.graphql
       └── subscriptions/
           └── (will be added in 14-2)
   ```

2. **Extract Queries from projects.go**:
   
   Create `api/internal/railway/queries/queries/project-by-id.graphql`:
   ```graphql
   query Project($id: ID!) {
     project(id: $id) {
       id
       name
     }
   }
   ```

   Create `api/internal/railway/queries/queries/project-details-by-id.graphql`:
   ```graphql
   query ProjectDetails($id: ID!) {
     project(id: $id) {
       id
       name
       services { edges { node { id name } } }
       environments {
         edges {
           node {
             id
             name
             serviceInstances {
               edges {
                 node {
                   buildCommand
                   builder
                   # ... all other fields
                 }
               }
             }
           }
         }
       }
     }
   }
   ```

3. **Update projects.go to use embed**:
   ```go
   package railway
   
   import (
       _ "embed"
   )
   
   //go:embed queries/queries/project-by-id.graphql
   var gqlProjectByID string
   
   //go:embed queries/queries/project-details-by-id.graphql
   var gqlProjectDetailsByID string
   
   //go:embed queries/queries/list-projects-root.graphql
   var gqlListProjectsRoot string
   
   //go:embed queries/queries/projects-details-root.graphql
   var gqlProjectsDetailsRoot string
   
   // GetProject fetches a single project by ID (id, name only).
   func (c *Client) GetProject(ctx context.Context, id string) (Project, error) {
       var out struct {
           Project struct {
               ID   string `json:"id"`
               Name string `json:"name"`
           } `json:"project"`
       }
       gql := gqlProjectByID  // Now references embedded file
       if err := c.execute(ctx, gql, map[string]any{"id": id}, &out); err != nil {
           return Project{}, err
       }
       return Project{ID: out.Project.ID, Name: out.Project.Name}, nil
   }
   ```

4. **Extract Mutations from projects.go and service.go**:
   
   Create `api/internal/railway/queries/mutations/project-create.graphql`:
   ```graphql
   mutation ProjectCreate($defaultEnvironmentName: String, $name: String) {
     projectCreate(input: { defaultEnvironmentName: $defaultEnvironmentName, name: $name }) {
       id
       name
       environments {
         edges {
           cursor
           node { id name }
         }
       }
     }
   }
   ```

   Update code similarly to use embed.

5. **Create README.md**:
   Create `api/internal/railway/queries/README.md`:
   ```markdown
   # Railway GraphQL Operations
   
   This directory contains all GraphQL queries, mutations, and subscriptions for the Railway API.
   
   ## Structure
   
   - `queries/` - Read operations (queries)
   - `mutations/` - Write operations (mutations)
   - `subscriptions/` - Real-time subscriptions (WebSocket)
   
   ## Naming Conventions
   
   - Use kebab-case for file names
   - Be descriptive: `project-by-id.graphql`, `service-create.graphql`
   - Match operation name when possible
   
   ## Usage
   
   Files are embedded at compile time using `//go:embed`:
   
   ```go
   //go:embed queries/queries/project-by-id.graphql
   var gqlProjectByID string
   ```
   
   Then used in functions:
   
   ```go
   func (c *Client) GetProject(ctx context.Context, id string) (Project, error) {
       gql := gqlProjectByID
       // ... use gql string
   }
   ```
   
   ## Adding New Operations
   
   1. Create `.graphql` file in appropriate subdirectory
   2. Add `//go:embed` directive in corresponding `.go` file
   3. Reference the embedded variable in your function
   ```

6. **Repeat for all existing queries/mutations**:
   - Extract all queries from `env.go`
   - Extract service mutations from `service.go`
   - Verify each one works with existing tests

7. **Testing**:
   - Run all existing integration tests to ensure no regressions
   - Queries should work exactly as before
   - No functional changes, only code organization

## Verification

- [ ] `queries/` directory created with proper structure
- [ ] All queries extracted from inline strings to `.graphql` files
- [ ] All mutations extracted to `.graphql` files
- [ ] `//go:embed` directives added for all operations
- [ ] README.md created in queries/ directory
- [ ] All existing tests pass without changes
- [ ] Code compiles without errors
- [ ] No functional changes to API behavior
- [ ] File naming follows conventions
- [ ] Pattern documented for future use

## Files Modified

- **New**: `api/internal/railway/queries/README.md`
- **New**: `api/internal/railway/queries/queries/*.graphql` (multiple files)
- **New**: `api/internal/railway/queries/mutations/*.graphql` (multiple files)
- **Modified**: `api/internal/railway/projects.go` (use embed)
- **Modified**: `api/internal/railway/service.go` (use embed)
- **Modified**: `api/internal/railway/env.go` (use embed)

## Test Plan

### Verification Tests

Since this is a refactoring with no functional changes:

1. **Compilation Test**:
   ```bash
   cd api && go build ./internal/railway/...
   ```
   Should compile without errors.

2. **Run Existing Integration Tests**:
   ```bash
   cd api && go test -v ./internal/railway/... -run Integration
   ```
   All existing tests should pass unchanged.

3. **Visual Inspection**:
   - Open `.graphql` files in IDE - should have syntax highlighting
   - Verify embed directives reference correct file paths
   - Confirm variable names match existing usage

### Manual Testing Checklist

- [ ] Build succeeds with no errors
- [ ] All integration tests pass
- [ ] GraphQL files have proper syntax
- [ ] Embedded variables accessible in code
- [ ] No runtime errors when executing queries

### Success Criteria

- Zero functional changes
- All tests pass
- Code is more maintainable
- Pattern established for new queries (logs)
- GraphQL syntax highlighting works in IDE

## Benefits for Subsequent Tasks

This refactoring enables:
- **Task 14-1**: Reference example `.graphql` files when researching Railway API
- **Task 14-2**: Add new `environment-logs.graphql` subscription following established pattern
  - Railway actually uses `environmentLogs` subscription (environment-level, aggregates all services)
  - Has built-in filtering, time-based pagination
  - Rich metadata with tags (projectId, environmentId, serviceId, deploymentId, deploymentInstanceId, snapshotId)
- **Future maintenance**: Easier to update queries, better IDE support
- **Testing**: Can validate GraphQL syntax independently
- **Documentation**: Queries serve as API documentation

## Note on Railway Log APIs

Railway provides multiple log-related GraphQL operations:
- `environmentLogs` subscription - Real-time logs for entire environment (all services)
- `deploymentLogs` query/subscription - Logs for specific deployment
- `buildLogs` query - Build logs for a deployment
- `events` query - Railway platform events

Task 14-1 will document these in detail.


# [14-3] Add log processing utilities for parsing and formatting

[Back to task list](./tasks.md)

## Description

Create utility functions for processing raw log lines to extract structured information, detect severity levels, handle ANSI color codes, and format logs for display. These utilities will be used by both the API endpoints and frontend to provide a consistent log viewing experience.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-04 00:00:00 | Created | N/A | Proposed | Task file created | ai-agent |

## Requirements

1. **Log Parsing**:
   - Parse various log formats: JSON logs, logfmt, plain text
   - Extract timestamp if present in log line
   - Detect and extract severity level (INFO, WARN, ERROR, DEBUG, TRACE)
   - Handle logs without explicit structure

2. **ANSI Code Handling**:
   - Strip ANSI color codes for plain text export
   - Optionally preserve codes for terminal display
   - Map ANSI colors to severity levels where possible

3. **Log Aggregation**:
   - Merge logs from multiple services chronologically
   - Preserve service identity in merged output
   - Handle timezone conversions consistently (use UTC)

4. **Severity Detection**:
   - Define constants for log levels
   - Implement heuristics to detect level from log content
   - Support common log level keywords and formats

5. **Formatting Utilities**:
   - Format timestamp consistently (ISO 8601 or configurable)
   - Truncate long messages with ellipsis
   - Prepare logs for JSON, CSV, and plain text export

## Implementation Plan

1. **Create Package Structure** in `api/internal/logutil/`:
   ```
   api/internal/logutil/
   ├── parser.go       # Log parsing functions
   ├── severity.go     # Severity detection
   ├── ansi.go         # ANSI code handling
   ├── aggregator.go   # Multi-service log merging
   └── format.go       # Export formatting
   ```

2. **Define Core Types** in `parser.go`:
   ```go
   const (
       SeverityDebug   = "DEBUG"
       SeverityInfo    = "INFO"
       SeverityWarn    = "WARN"
       SeverityError   = "ERROR"
       SeverityUnknown = "UNKNOWN"
   )

   type ParsedLog struct {
       Timestamp   time.Time
       Severity    string
       Message     string
       ServiceName string
       RawLine     string
       Structured  map[string]interface{} // For JSON logs
   }

   func ParseLogLine(line string, serviceName string) ParsedLog
   func ParseJSONLog(line string, serviceName string) (ParsedLog, error)
   func ParseLogfmt(line string, serviceName string) (ParsedLog, error)
   ```

3. **Implement Severity Detection** in `severity.go`:
   - Pattern matching for common log level formats
   - Case-insensitive keyword detection
   - Support for emoji/unicode log indicators
   - Default to UNKNOWN if unable to determine

4. **Implement ANSI Handling** in `ansi.go`:
   ```go
   func StripANSI(text string) string
   func ANSIToSeverity(ansiCode string) string
   ```

5. **Implement Aggregation** in `aggregator.go`:
   ```go
   type LogAggregator struct {
       logs []ParsedLog
   }

   func NewLogAggregator() *LogAggregator
   func (a *LogAggregator) Add(logs []ParsedLog)
   func (a *LogAggregator) GetMerged() []ParsedLog // Sorted by timestamp
   ```

6. **Implement Formatting** in `format.go`:
   ```go
   func FormatAsJSON(logs []ParsedLog) ([]byte, error)
   func FormatAsCSV(logs []ParsedLog) ([]byte, error)
   func FormatAsPlainText(logs []ParsedLog) ([]byte, error)
   ```

7. **Testing**:
   - Unit tests for each parser type (JSON, logfmt, plain)
   - Tests for severity detection with various formats
   - Tests for ANSI code stripping
   - Tests for chronological merging
   - Tests for export formatters

## Verification

- [ ] `logutil` package created with modular structure
- [ ] `ParseLogLine` function handles JSON, logfmt, and plain text
- [ ] Severity detection works for common log formats
- [ ] ANSI code stripping works correctly
- [ ] Log aggregation merges by timestamp correctly
- [ ] Export formatters produce valid JSON, CSV, and plain text
- [ ] Timezone handling is consistent (UTC)
- [ ] All functions have unit tests with >80% coverage
- [ ] No external dependencies beyond Go standard library and zerolog
- [ ] Code is well-documented with examples
- [ ] All tests pass
- [ ] No linter errors

## Files Modified

- **New**: `api/internal/logutil/parser.go`
- **New**: `api/internal/logutil/parser_test.go`
- **New**: `api/internal/logutil/severity.go`
- **New**: `api/internal/logutil/severity_test.go`
- **New**: `api/internal/logutil/ansi.go`
- **New**: `api/internal/logutil/ansi_test.go`
- **New**: `api/internal/logutil/aggregator.go`
- **New**: `api/internal/logutil/aggregator_test.go`
- **New**: `api/internal/logutil/format.go`
- **New**: `api/internal/logutil/format_test.go`

## Test Plan

### Parser Tests
```go
func TestParseLogLine_JSON(t *testing.T) {
    line := `{"timestamp":"2024-01-01T12:00:00Z","level":"INFO","msg":"Server started"}`
    result := ParseLogLine(line, "api")
    assert.Equal(t, SeverityInfo, result.Severity)
    assert.Equal(t, "Server started", result.Message)
}

func TestParseLogLine_PlainText(t *testing.T) {
    line := "[ERROR] 2024-01-01 12:00:00 Database connection failed"
    result := ParseLogLine(line, "api")
    assert.Equal(t, SeverityError, result.Severity)
}
```

### Severity Detection Tests
```go
func TestDetectSeverity(t *testing.T) {
    cases := []struct {
        line     string
        expected string
    }{
        {"INFO: message", SeverityInfo},
        {"[ERROR] message", SeverityError},
        {"WARN message", SeverityWarn},
        {"🐛 debug message", SeverityDebug},
        {"plain message", SeverityUnknown},
    }
    // Test each case
}
```

### ANSI Tests
```go
func TestStripANSI(t *testing.T) {
    input := "\x1b[31mError:\x1b[0m Something failed"
    expected := "Error: Something failed"
    assert.Equal(t, expected, StripANSI(input))
}
```

### Aggregation Tests
```go
func TestLogAggregator_ChronologicalMerge(t *testing.T) {
    agg := NewLogAggregator()
    
    // Add logs from service A
    logsA := []ParsedLog{
        {Timestamp: time1, ServiceName: "api"},
        {Timestamp: time3, ServiceName: "api"},
    }
    
    // Add logs from service B
    logsB := []ParsedLog{
        {Timestamp: time2, ServiceName: "web"},
    }
    
    agg.Add(logsA)
    agg.Add(logsB)
    
    merged := agg.GetMerged()
    // Verify chronological order: time1, time2, time3
    assert.Equal(t, time1, merged[0].Timestamp)
    assert.Equal(t, time2, merged[1].Timestamp)
    assert.Equal(t, time3, merged[2].Timestamp)
}
```

### Export Format Tests
```go
func TestFormatAsCSV(t *testing.T) {
    logs := []ParsedLog{
        {Timestamp: time1, Severity: SeverityInfo, Message: "test", ServiceName: "api"},
    }
    csv, err := FormatAsCSV(logs)
    require.NoError(t, err)
    // Verify CSV structure
    assert.Contains(t, string(csv), "Timestamp,Service,Level,Message")
}
```

### Success Criteria
- All unit tests pass
- Test coverage >80%
- Handles various log formats gracefully
- ANSI stripping works correctly
- Aggregation maintains chronological order
- Export formats are valid


# [14-2] Implement Railway log subscription and fetching in Go client

[Back to task list](./tasks.md)

## Description

Add log subscription and fetching capabilities to the Railway client package (`api/internal/railway/`) to receive real-time logs via GraphQL subscriptions and query historical logs. This uses a hybrid approach: keeping the existing `machinebox/graphql` for queries and adding `github.com/coder/websocket` for WebSocket-based subscriptions (following Railway's proven pattern from task 14-1).

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-04 00:00:00 | Created | N/A | Proposed | Task file created | ai-agent |
| 2025-10-05 00:00:00 | Status Update | Proposed | InProgress | Started implementation using Railway's proven pattern from task 14-1 | Sean |
| 2025-10-05 00:00:00 | Implementation | InProgress | InProgress | Implemented WebSocket subscription client using Railway's pattern | Sean |
| 2025-10-05 00:00:00 | Status Update | InProgress | Done | Completed implementation with proper separation of concerns | Sean |

## Requirements

1. **Add Subscription Client to Railway Client**:
   - **Prerequisite**: Task 14-0 completed (GraphQL files pattern established)
   - Add `hasura/go-graphql-client` dependency for subscriptions
   - Extend Railway `Client` struct to support subscriptions
   - Keep existing `machinebox/graphql` for queries/mutations
   - Initialize subscription client with Railway's WebSocket endpoint

2. **Real-time Log Subscription**:
   - Create `SubscribeToEnvironmentLogs` function for real-time logs
   - Subscribe to Railway's `environmentLogs` GraphQL subscription (aggregates all services in environment)
   - Support optional text filtering via `filter` parameter
   - Support time-based pagination via anchor dates and limits
   - Return channel that receives log entries as they arrive
   - Handle subscription lifecycle (connect, receive, disconnect)
   - Implement automatic reconnection on connection loss

3. **Historical Log Query**:
   - Create `GetDeploymentLogs` function for historical logs
   - Support time range filtering (from/to timestamps)
   - Support pagination (limit, cursor/offset)
   - Use existing `execute()` method with `machinebox/graphql`

4. **Data Structures**:
   - Define Go struct for log entry: `DeploymentLog`
   - Include fields: timestamp, message, level/severity, service name, deployment ID
   - Support pagination metadata for historical queries

5. **Error Handling**:
   - Handle subscription connection errors gracefully
   - Implement reconnection with exponential backoff
   - Handle historical query errors with existing retry logic
   - Return meaningful error messages for common failures

6. **Integration**:
   - Follow existing Railway client patterns
   - Maintain thread-safety for subscription management
   - Include comprehensive logging using zerolog

## Implementation Plan

1. **Add Dependencies** (based on task 14-1 findings):
   ```bash
   go get github.com/coder/websocket@latest
   # Note: google/uuid is already in the project
   ```

2. **Update Client Struct** in `api/internal/railway/client.go`:
   ```go
   import (
       "github.com/machinebox/graphql"
       hasura "github.com/hasura/go-graphql-client"
   )

   type Client struct {
       endpoint             string
       token                string
       httpc                *http.Client
       subscriptionEndpoint string  // WebSocket endpoint
   }

   func NewClient(endpoint, token string, httpc *http.Client) *Client {
       if endpoint == "" {
           endpoint = DefaultEndpoint
       }
       // Convert HTTP endpoint to WebSocket endpoint
       subscriptionEndpoint := strings.Replace(endpoint, "https://", "wss://", 1)
       subscriptionEndpoint = strings.Replace(subscriptionEndpoint, "http://", "ws://", 1)
       
       if httpc == nil {
           httpc = &http.Client{Timeout: 30 * time.Second}
       }
       return &Client{
           endpoint:             endpoint,
           token:                token,
           httpc:                httpc,
           subscriptionEndpoint: subscriptionEndpoint,
       }
   }
   ```

3. **Create GraphQL Files** following task 14-0 pattern:
   
   Create `api/internal/railway/queries/subscriptions/environment-logs.graphql`:
   ```graphql
   subscription StreamEnvironmentLogs(
     $environmentId: String!
     $filter: String
     $beforeLimit: Int!
     $beforeDate: String
     $anchorDate: String
     $afterDate: String
     $afterLimit: Int
   ) {
     environmentLogs(
       environmentId: $environmentId
       filter: $filter
       beforeDate: $beforeDate
       anchorDate: $anchorDate
       afterDate: $afterDate
       beforeLimit: $beforeLimit
       afterLimit: $afterLimit
     ) {
       timestamp
       message
       severity
       tags {
         projectId
         environmentId
         serviceId
         deploymentId
         deploymentInstanceId
         snapshotId
       }
       attributes {
         key
         value
       }
     }
   }
   ```
   
   Note: Historical logs can use the same subscription with date ranges, or we can add a separate query if Railway provides one.

4. **Define Data Structures** in `api/internal/railway/logs.go`:
   ```go
   // LogTags contains Railway metadata for a log entry
   type LogTags struct {
       ProjectID            string `json:"projectId"`
       EnvironmentID        string `json:"environmentId"`
       ServiceID            string `json:"serviceId,omitempty"`
       DeploymentID         string `json:"deploymentId,omitempty"`
       DeploymentInstanceID string `json:"deploymentInstanceId,omitempty"`
       SnapshotID           string `json:"snapshotId,omitempty"`
   }

   // LogAttribute represents a custom key-value attribute
   type LogAttribute struct {
       Key   string `json:"key"`
       Value string `json:"value"`
   }

   // EnvironmentLog represents a log entry from Railway
   type EnvironmentLog struct {
       Timestamp  time.Time      `json:"timestamp"`
       Message    string         `json:"message"`
       Severity   string         `json:"severity"`
       Tags       LogTags        `json:"tags"`
       Attributes []LogAttribute `json:"attributes"`
   }

   // SubscribeEnvironmentLogsInput contains parameters for log subscription
   type SubscribeEnvironmentLogsInput struct {
       EnvironmentID string
       Filter        *string  // Optional text filter
       BeforeDate    *string  // ISO timestamp
       AnchorDate    *string  // ISO timestamp for pagination anchor
       AfterDate     *string  // ISO timestamp
       BeforeLimit   int      // Number of logs before anchor
       AfterLimit    int      // Number of logs after anchor
   }
   ```

5. **Add Embed Directives** in `api/internal/railway/logs.go`:
   ```go
   package railway
   
   import (
       _ "embed"
       "context"
       "time"
       hasura "github.com/hasura/go-graphql-client"
       "github.com/rs/zerolog/log"
   )
   
   //go:embed queries/subscriptions/environment-logs.graphql
   var gqlEnvironmentLogsSubscription string
   ```

6. **Implement Subscription Method** in `api/internal/railway/logs.go`:
   ```go
   // SubscribeToEnvironmentLogs creates a real-time subscription to environment logs
   // This aggregates logs from all services in the environment
   func (c *Client) SubscribeToEnvironmentLogs(
       ctx context.Context,
       input SubscribeEnvironmentLogsInput,
       logChan chan<- EnvironmentLog,
   ) error {
       // Create subscription client
       client := hasura.NewSubscriptionClient(c.subscriptionEndpoint).
           WithConnectionParams(map[string]interface{}{
               "headers": map[string]string{
                   "Authorization": "Bearer " + c.token,
               },
           })
       
       defer client.Close()

       // Define subscription matching Railway's schema
       var subscription struct {
           EnvironmentLogs struct {
               Timestamp  time.Time `graphql:"timestamp"`
               Message    string    `graphql:"message"`
               Severity   string    `graphql:"severity"`
               Tags       struct {
                   ProjectID            string `graphql:"projectId"`
                   EnvironmentID        string `graphql:"environmentId"`
                   ServiceID            string `graphql:"serviceId"`
                   DeploymentID         string `graphql:"deploymentId"`
                   DeploymentInstanceID string `graphql:"deploymentInstanceId"`
                   SnapshotID           string `graphql:"snapshotId"`
               } `graphql:"tags"`
               Attributes []struct {
                   Key   string `graphql:"key"`
                   Value string `graphql:"value"`
               } `graphql:"attributes"`
           } `graphql:"environmentLogs(environmentId: $environmentId, filter: $filter, beforeDate: $beforeDate, anchorDate: $anchorDate, afterDate: $afterDate, beforeLimit: $beforeLimit, afterLimit: $afterLimit)"`
       }

       // Build variables
       variables := map[string]interface{}{
           "environmentId": hasura.String(input.EnvironmentID),
           "beforeLimit":   hasura.Int(input.BeforeLimit),
           "afterLimit":    hasura.Int(input.AfterLimit),
       }
       if input.Filter != nil {
           variables["filter"] = hasura.String(*input.Filter)
       }
       if input.BeforeDate != nil {
           variables["beforeDate"] = hasura.String(*input.BeforeDate)
       }
       if input.AnchorDate != nil {
           variables["anchorDate"] = hasura.String(*input.AnchorDate)
       }
       if input.AfterDate != nil {
           variables["afterDate"] = hasura.String(*input.AfterDate)
       }

       // Start subscription
       _, err := client.Subscribe(&subscription, variables, func(data []byte, err error) error {
           if err != nil {
               log.Error().Err(err).Msg("subscription error")
               return err
           }

           // Convert to our domain model
           attrs := make([]LogAttribute, len(subscription.EnvironmentLogs.Attributes))
           for i, attr := range subscription.EnvironmentLogs.Attributes {
               attrs[i] = LogAttribute{Key: attr.Key, Value: attr.Value}
           }

           logEntry := EnvironmentLog{
               Timestamp: subscription.EnvironmentLogs.Timestamp,
               Message:   subscription.EnvironmentLogs.Message,
               Severity:  subscription.EnvironmentLogs.Severity,
               Tags: LogTags{
                   ProjectID:            subscription.EnvironmentLogs.Tags.ProjectID,
                   EnvironmentID:        subscription.EnvironmentLogs.Tags.EnvironmentID,
                   ServiceID:            subscription.EnvironmentLogs.Tags.ServiceID,
                   DeploymentID:         subscription.EnvironmentLogs.Tags.DeploymentID,
                   DeploymentInstanceID: subscription.EnvironmentLogs.Tags.DeploymentInstanceID,
                   SnapshotID:           subscription.EnvironmentLogs.Tags.SnapshotID,
               },
               Attributes: attrs,
           }

           select {
           case logChan <- logEntry:
           case <-ctx.Done():
               return ctx.Err()
           }

           return nil
       })

       if err != nil {
           return err
       }

       // Run until context cancelled
       return client.Run()
   }
   ```

7. **Historical Logs**:
   
   For historical logs, we can use the same `environmentLogs` subscription with date ranges:
   
   ```go
   // GetHistoricalLogs fetches historical logs using subscription with time range
   // This is a convenience wrapper that uses the subscription for historical data
   func (c *Client) GetHistoricalLogs(
       ctx context.Context,
       environmentID string,
       from time.Time,
       to time.Time,
       limit int,
   ) ([]EnvironmentLog, error) {
       logChan := make(chan EnvironmentLog, limit)
       logs := make([]EnvironmentLog, 0, limit)
       
       fromStr := from.Format(time.RFC3339)
       toStr := to.Format(time.RFC3339)
       
       input := SubscribeEnvironmentLogsInput{
           EnvironmentID: environmentID,
           AnchorDate:    &fromStr,
           AfterDate:     &toStr,
           BeforeLimit:   0,
           AfterLimit:    limit,
       }
       
       // Create context with timeout for historical fetch
       fetchCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
       defer cancel()
       
       // Start subscription in goroutine
       errChan := make(chan error, 1)
       go func() {
           errChan <- c.SubscribeToEnvironmentLogs(fetchCtx, input, logChan)
       }()
       
       // Collect logs until done or error
       for {
           select {
           case log := <-logChan:
               logs = append(logs, log)
               if len(logs) >= limit {
                   cancel() // Got enough logs
                   return logs, nil
               }
           case err := <-errChan:
               if err != nil && err != context.Canceled {
                   return logs, err
               }
               return logs, nil
           case <-fetchCtx.Done():
               return logs, nil
           }
       }
   }
   ```
   
   Note: Task 14-1 will research if Railway also provides a dedicated query for historical logs.

8. **Testing**:
   - Add unit tests for struct marshaling
   - Add integration test for historical query
   - Add integration test for subscription (skipped if no token)
   - Test reconnection logic
   - Test context cancellation

## Verification

- [ ] `hasura/go-graphql-client` dependency added to go.mod
- [ ] `Client` struct updated with subscription endpoint
- [ ] `logs.go` file created in `api/internal/railway/` package
- [ ] `DeploymentLog` struct defined with required fields
- [ ] `LogTags` and `LogAttribute` structs defined
- [ ] `EnvironmentLog` struct defined with tags and attributes
- [ ] `SubscribeEnvironmentLogsInput` struct defined
- [ ] `SubscribeToEnvironmentLogs` method implemented for real-time logs
- [ ] Subscription uses hasura/go-graphql-client
- [ ] Subscription handles authentication with Bearer token
- [ ] Subscription returns logs via channel
- [ ] Context cancellation stops subscription
- [ ] `GetHistoricalLogs` method implemented using subscription with time range
- [ ] Service identification works via tags.serviceId field
- [ ] Time range filtering works correctly
- [ ] Error handling follows existing Railway client patterns
- [ ] Logging uses zerolog consistent with other Railway functions
- [ ] Unit tests added for data structures
- [ ] Integration test added for subscription (with skip if no token)
- [ ] Integration test added for historical query
- [ ] Code compiles without errors
- [ ] Follows Go conventions and project style

## Implementation Summary

### Completed (2025-10-05)

**Dependencies:**
- ✅ Added `github.com/coder/websocket v1.8.14`
- ✅ Using existing `github.com/google/uuid v1.6.0`

**Files Created:**
- ✅ `api/internal/railway/queries/subscriptions/environment-logs.graphql` - GraphQL subscription definition
- ✅ `api/internal/railway/logs.go` - WebSocket subscription implementation following Railway's proven pattern
- ✅ `api/internal/railway/logs_test.go` - Unit and integration tests

**Files Modified:**
- ✅ `api/internal/railway/client.go` - Added WebSocket endpoint configuration
  - Updated DefaultEndpoint to correct domain (`.app` not `.com`)
  - Added DefaultWSEndpoint constant
  - Added `wsEndpoint` field to Client struct
- ✅ `api/go.mod` - Added websocket dependency

**Implementation Details:**
- Used Railway's exact WebSocket connection pattern (3-step handshake)
- Implemented `CreateWebSocketSubscription()` for generic WebSocket subscriptions
- Implemented `SubscribeToEnvironmentLogs()` with seamless resuming (5-min backfill, 500 log limit)
- Implemented `ReadLogMessage()` helper for parsing log messages
- All code compiles without errors
- Unit tests pass successfully
- No linter errors

## Files Modified

- **New**: `api/internal/railway/queries/subscriptions/environment-logs.graphql`
- **New**: `api/internal/railway/logs.go`
- **New**: `api/internal/railway/logs_test.go`
- **Modified**: `api/internal/railway/client.go` (added WebSocket endpoint fields)
- **Modified**: `api/go.mod` (added github.com/coder/websocket dependency)
- **Modified**: `api/go.sum` (dependency checksums)

## Test Plan

### Unit Tests
- Test `DeploymentLog` struct JSON marshaling/unmarshaling
- Test input validation for `GetDeploymentLogsInput`
- Test pagination logic with mock responses

### Integration Tests

```go
func TestIntegration_SubscribeToEnvironmentLogs(t *testing.T) {
    token := os.Getenv("RAILWAY_API_TOKEN")
    environmentID := os.Getenv("TEST_ENVIRONMENT_ID")
    if token == "" || environmentID == "" {
        t.Skip("RAILWAY_API_TOKEN and TEST_ENVIRONMENT_ID not set")
    }
    
    client := NewClient("", token, nil)
    logChan := make(chan EnvironmentLog, 10)
    
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    input := SubscribeEnvironmentLogsInput{
        EnvironmentID: environmentID,
        BeforeLimit:   0,
        AfterLimit:    100,
    }
    
    // Start subscription in goroutine
    errChan := make(chan error)
    go func() {
        errChan <- client.SubscribeToEnvironmentLogs(ctx, input, logChan)
    }()
    
    // Wait for at least one log or timeout
    select {
    case log := <-logChan:
        require.NotEmpty(t, log.Message)
        require.NotEmpty(t, log.Tags.EnvironmentID)
        t.Logf("Received log from service %s: %s", log.Tags.ServiceID, log.Message)
    case err := <-errChan:
        require.NoError(t, err)
    case <-ctx.Done():
        t.Log("Test timed out, no logs received (may be expected if no active services)")
    }
}

func TestIntegration_GetHistoricalLogs(t *testing.T) {
    token := os.Getenv("RAILWAY_API_TOKEN")
    environmentID := os.Getenv("TEST_ENVIRONMENT_ID")
    if token == "" || environmentID == "" {
        t.Skip("credentials not set")
    }
    
    client := NewClient("", token, nil)
    
    // Get logs from last hour
    from := time.Now().Add(-1 * time.Hour)
    to := time.Now()
    
    logs, err := client.GetHistoricalLogs(context.Background(), environmentID, from, to, 100)
    
    require.NoError(t, err)
    t.Logf("Received %d historical logs", len(logs))
    
    // Verify logs have required fields
    if len(logs) > 0 {
        require.NotEmpty(t, logs[0].Message)
        require.NotEmpty(t, logs[0].Tags.EnvironmentID)
    }
}
```

### Success Criteria
- All unit tests pass
- Integration tests pass when credentials available
- No linter errors
- Code follows existing Railway client patterns


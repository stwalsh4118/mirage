# [14-9] Implement log export functionality (JSON, CSV, TXT)

[Back to task list](./tasks.md)

## Description

Implement the frontend log export functionality that allows users to download logs in various formats (JSON, CSV, plain text) for offline analysis or sharing with team members. This includes calling the export API endpoint and triggering file downloads.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-04 00:00:00 | Created | N/A | Proposed | Task file created | ai-agent |

## Requirements

1. **Export Button Component**:
   - Dropdown menu with format options
   - Options: JSON, CSV, Plain Text
   - Disable while export in progress
   - Show loading spinner during export

2. **Export API Integration**:
   - Call GET `/api/logs/export` endpoint
   - Pass current filters as query parameters
   - Handle response blob
   - Trigger browser download with appropriate filename

3. **File Download**:
   - Generate filename: `{environment-name}-logs-{timestamp}.{ext}`
   - Set correct MIME type for each format
   - Use browser download API to save file

4. **Error Handling**:
   - Show error toast if export fails
   - Handle timeout for large exports
   - Display meaningful error messages

5. **User Feedback**:
   - Show loading indicator during export
   - Display success toast after download
   - Show export size/count before download (optional)

## Implementation Plan

1. **Create Export Hook** in `web/src/hooks/useLogExport.ts`:
   ```tsx
   import { useState } from 'react'
   import { toast } from 'sonner'

   interface ExportOptions {
     environmentId: string
     format: 'json' | 'csv' | 'txt'
     filters?: {
       services?: string[]
       from?: Date
       to?: Date
       search?: string
       levels?: string[]
     }
   }

   export function useLogExport() {
     const [exporting, setExporting] = useState(false)

     const exportLogs = async (options: ExportOptions) => {
       setExporting(true)

       try {
         // Build query parameters
         const params = new URLSearchParams()
         params.set('environmentId', options.environmentId)
         params.set('format', options.format)

         if (options.filters?.services?.length) {
           params.set('services', options.filters.services.join(','))
         }
         if (options.filters?.from) {
           params.set('from', options.filters.from.toISOString())
         }
         if (options.filters?.to) {
           params.set('to', options.filters.to.toISOString())
         }
         if (options.filters?.search) {
           params.set('search', options.filters.search)
         }
         if (options.filters?.levels?.length) {
           params.set('levels', options.filters.levels.join(','))
         }

         // Fetch logs
         const response = await fetch(`/api/logs/export?${params.toString()}`)

         if (!response.ok) {
           throw new Error(`Export failed: ${response.statusText}`)
         }

         // Get filename from Content-Disposition header or generate one
         const contentDisposition = response.headers.get('Content-Disposition')
         let filename = `logs-${new Date().toISOString()}.${options.format}`
         
         if (contentDisposition) {
           const filenameMatch = contentDisposition.match(/filename="?([^"]+)"?/)
           if (filenameMatch) {
             filename = filenameMatch[1]
           }
         }

         // Download file
         const blob = await response.blob()
         const url = window.URL.createObjectURL(blob)
         const link = document.createElement('a')
         link.href = url
         link.download = filename
         document.body.appendChild(link)
         link.click()
         document.body.removeChild(link)
         window.URL.revokeObjectURL(url)

         toast.success(`Logs exported to ${filename}`)
       } catch (error) {
         console.error('Export failed:', error)
         toast.error(
           error instanceof Error
             ? error.message
             : 'Failed to export logs'
         )
       } finally {
         setExporting(false)
       }
     }

     return {
       exportLogs,
       exporting,
     }
   }
   ```

2. **Update ExportButton Component** in `web/src/components/logs/ExportButton.tsx`:
   ```tsx
   import { Button } from '@/components/ui/button'
   import {
     DropdownMenu,
     DropdownMenuContent,
     DropdownMenuItem,
     DropdownMenuTrigger,
   } from '@/components/ui/dropdown-menu'
   import { Download, Loader2 } from 'lucide-react'
   import { useLogExport } from '@/hooks/useLogExport'

   interface ExportButtonProps {
     environmentId: string
     filters?: {
       services?: string[]
       from?: Date
       to?: Date
       search?: string
       levels?: string[]
     }
   }

   export function ExportButton({ environmentId, filters }: ExportButtonProps) {
     const { exportLogs, exporting } = useLogExport()

     const handleExport = (format: 'json' | 'csv' | 'txt') => {
       exportLogs({
         environmentId,
         format,
         filters,
       })
     }

     return (
       <DropdownMenu>
         <DropdownMenuTrigger asChild>
           <Button variant="outline" size="sm" disabled={exporting}>
             {exporting ? (
               <Loader2 className="h-4 w-4 mr-2 animate-spin" />
             ) : (
               <Download className="h-4 w-4 mr-2" />
             )}
             Export
           </Button>
         </DropdownMenuTrigger>
         <DropdownMenuContent align="end">
           <DropdownMenuItem onClick={() => handleExport('json')}>
             Export as JSON
           </DropdownMenuItem>
           <DropdownMenuItem onClick={() => handleExport('csv')}>
             Export as CSV
           </DropdownMenuItem>
           <DropdownMenuItem onClick={() => handleExport('txt')}>
             Export as Plain Text
           </DropdownMenuItem>
         </DropdownMenuContent>
       </DropdownMenu>
     )
   }
   ```

3. **Testing**:
   - Mock fetch API for tests
   - Test file download trigger
   - Test error handling
   - Test loading states

## Verification

- [ ] `useLogExport` hook created
- [ ] ExportButton component updated to use hook
- [ ] Export API call constructed correctly
- [ ] File download triggered with correct filename
- [ ] MIME types handled correctly for each format
- [ ] Loading state displayed during export
- [ ] Success toast shown after download
- [ ] Error handling works with appropriate messages
- [ ] Disabled state during export prevents duplicate requests
- [ ] Tests added and passing

## Files Modified

- **New**: `web/src/hooks/useLogExport.ts`
- **New**: `web/src/hooks/useLogExport.test.ts`
- **Modified**: `web/src/components/logs/ExportButton.tsx`

## Test Plan

### Hook Tests

```tsx
import { renderHook, act, waitFor } from '@testing-library/react'
import { useLogExport } from './useLogExport'

// Mock fetch
global.fetch = jest.fn()

// Mock toast
jest.mock('sonner', () => ({
  toast: {
    success: jest.fn(),
    error: jest.fn(),
  },
}))

describe('useLogExport', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  it('exports logs successfully', async () => {
    const mockBlob = new Blob(['log data'], { type: 'application/json' })
    ;(global.fetch as jest.Mock).mockResolvedValue({
      ok: true,
      blob: async () => mockBlob,
      headers: new Headers({
        'Content-Disposition': 'attachment; filename="test-logs.json"',
      }),
    })

    // Mock URL.createObjectURL
    global.URL.createObjectURL = jest.fn(() => 'blob:mock-url')
    global.URL.revokeObjectURL = jest.fn()

    // Mock DOM
    const mockLink = {
      href: '',
      download: '',
      click: jest.fn(),
    }
    document.createElement = jest.fn(() => mockLink as any)
    document.body.appendChild = jest.fn()
    document.body.removeChild = jest.fn()

    const { result } = renderHook(() => useLogExport())

    await act(async () => {
      await result.current.exportLogs({
        environmentId: 'test-env',
        format: 'json',
      })
    })

    expect(global.fetch).toHaveBeenCalledWith(
      expect.stringContaining('/api/logs/export')
    )
    expect(mockLink.click).toHaveBeenCalled()
    expect(mockLink.download).toBe('test-logs.json')
  })

  it('handles export errors', async () => {
    ;(global.fetch as jest.Mock).mockResolvedValue({
      ok: false,
      statusText: 'Internal Server Error',
    })

    const { result } = renderHook(() => useLogExport())

    await act(async () => {
      await result.current.exportLogs({
        environmentId: 'test-env',
        format: 'json',
      })
    })

    const { toast } = require('sonner')
    expect(toast.error).toHaveBeenCalledWith(
      expect.stringContaining('Export failed')
    )
  })

  it('sets exporting state during export', async () => {
    const mockBlob = new Blob(['log data'])
    ;(global.fetch as jest.Mock).mockImplementation(
      () =>
        new Promise((resolve) =>
          setTimeout(
            () =>
              resolve({
                ok: true,
                blob: async () => mockBlob,
                headers: new Headers(),
              }),
            100
          )
        )
    )

    const { result } = renderHook(() => useLogExport())

    expect(result.current.exporting).toBe(false)

    act(() => {
      result.current.exportLogs({
        environmentId: 'test-env',
        format: 'json',
      })
    })

    expect(result.current.exporting).toBe(true)

    await waitFor(() => {
      expect(result.current.exporting).toBe(false)
    })
  })
})
```

### Manual Testing Checklist
- [ ] Click export button and select JSON format
- [ ] Verify file downloads with correct name
- [ ] Open downloaded JSON file and verify structure
- [ ] Export as CSV and verify format
- [ ] Export as TXT and verify format
- [ ] Verify filters applied to export
- [ ] Test export with large log volume
- [ ] Test error handling (disconnect network)
- [ ] Verify loading state during export
- [ ] Verify success toast after download

### Success Criteria
- Export works for all formats
- Files download with appropriate names
- Filters applied correctly
- Error handling graceful
- Tests pass


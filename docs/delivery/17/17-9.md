# [17-9] Implement Railway token management in SecretStore

[Back to task list](./tasks.md)

## Description

Implement Railway token management methods in the Vault SecretStore: store, get, delete, rotate, and validate Railway API tokens. These methods will enable per-user Railway token storage with versioning support.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-09 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |

## Requirements

1. Implement `StoreRailwayToken` - Store Railway token with metadata
2. Implement `GetRailwayToken` - Retrieve Railway token with caching
3. Implement `DeleteRailwayToken` - Remove Railway token and invalidate cache
4. Implement `RotateRailwayToken` - Store new version of token
5. Implement `ValidateRailwayToken` - Test token validity with Railway API
6. Use Vault KV v2 API for versioned storage
7. Integrate with caching layer
8. Add logging for all operations

## Implementation Plan

### Phase 1: StoreRailwayToken
1. Implement in `railway_secrets.go`:
   ```go
   func (c *Client) StoreRailwayToken(ctx context.Context, userID, token string) error {
       if token == "" {
           return ErrInvalidSecret
       }
       
       path := BuildSecretPath(c.mountPath, userID, PathRailway)
       metadata := SecretMetadata{
           CreatedBy:  userID,
           CreatedAt:  time.Now(),
           SecretType: SecretTypeRailway,
       }
       
       data := map[string]interface{}{
           "token":    token,
           "metadata": metadata,
       }
       
       err := c.executeWithCircuitBreaker(ctx, func() error {
           _, err := c.client.Logical().Write(
               fmt.Sprintf("%s/data/%s", c.mountPath, path),
               map[string]interface{}{"data": data},
           )
           return err
       })
       
       if err != nil {
           return fmt.Errorf("failed to store railway token: %w", err)
       }
       
       // Cache the token
       cacheKey := c.makeCacheKey(userID, PathRailway)
       c.cache.Set(cacheKey, token)
       
       log.Info().Str("user_id", userID).Msg("stored railway token")
       return nil
   }
   ```

### Phase 2: GetRailwayToken
1. Implement with cache-first strategy:
   ```go
   func (c *Client) GetRailwayToken(ctx context.Context, userID string) (string, error) {
       // Check cache first
       cacheKey := c.makeCacheKey(userID, PathRailway)
       if cached, found := c.cache.Get(cacheKey); found {
           log.Debug().Str("user_id", userID).Msg("railway token cache hit")
           return cached.(string), nil
       }
       
       // Fetch from Vault
       path := BuildSecretPath(c.mountPath, userID, PathRailway)
       var secret *api.Secret
       
       err := c.executeWithCircuitBreaker(ctx, func() error {
           var err error
           secret, err = c.client.Logical().Read(
               fmt.Sprintf("%s/data/%s", c.mountPath, path),
           )
           return err
       })
       
       if err != nil {
           return "", fmt.Errorf("failed to read railway token: %w", err)
       }
       
       if secret == nil || secret.Data == nil {
           return "", ErrSecretNotFound
       }
       
       data, ok := secret.Data["data"].(map[string]interface{})
       if !ok {
           return "", errors.New("invalid secret data format")
       }
       
       token, ok := data["token"].(string)
       if !ok {
           return "", errors.New("token not found in secret")
       }
       
       // Update cache
       c.cache.Set(cacheKey, token)
       
       log.Debug().Str("user_id", userID).Msg("retrieved railway token from vault")
       return token, nil
   }
   ```

### Phase 3: DeleteRailwayToken
1. Implement deletion with cache invalidation:
   ```go
   func (c *Client) DeleteRailwayToken(ctx context.Context, userID string) error {
       path := BuildSecretPath(c.mountPath, userID, PathRailway)
       
       err := c.executeWithCircuitBreaker(ctx, func() error {
           _, err := c.client.Logical().Delete(
               fmt.Sprintf("%s/data/%s", c.mountPath, path),
           )
           return err
       })
       
       if err != nil {
           return fmt.Errorf("failed to delete railway token: %w", err)
       }
       
       // Invalidate cache
       cacheKey := c.makeCacheKey(userID, PathRailway)
       c.cache.Delete(cacheKey)
       
       log.Info().Str("user_id", userID).Msg("deleted railway token")
       return nil
   }
   ```

### Phase 4: RotateRailwayToken
1. Implement rotation (creates new version):
   ```go
   func (c *Client) RotateRailwayToken(ctx context.Context, userID, newToken string) error {
       // This is essentially the same as StoreRailwayToken
       // KV v2 automatically versions on write
       if err := c.StoreRailwayToken(ctx, userID, newToken); err != nil {
           return fmt.Errorf("failed to rotate railway token: %w", err)
       }
       
       log.Info().Str("user_id", userID).Msg("rotated railway token")
       return nil
   }
   ```

### Phase 5: ValidateRailwayToken
1. Implement validation by calling Railway API:
   ```go
   func (c *Client) ValidateRailwayToken(ctx context.Context, userID string) error {
       token, err := c.GetRailwayToken(ctx, userID)
       if err != nil {
           return err
       }
       
       // Create temporary Railway client
       railwayClient := railway.NewClient("", token, nil)
       
       // Try a simple API call to validate token
       // We'll use the me query as a lightweight validation
       query := `query { me { id email } }`
       var result map[string]interface{}
       
       err = railwayClient.Execute(ctx, query, nil, &result)
       if err != nil {
           return fmt.Errorf("railway token validation failed: %w", err)
       }
       
       // Update last validated timestamp
       path := BuildSecretPath(c.mountPath, userID, PathRailway)
       now := time.Now()
       
       _ = c.executeWithCircuitBreaker(ctx, func() error {
           _, err := c.client.Logical().JSONMergePatch(
               ctx,
               fmt.Sprintf("%s/data/%s", c.mountPath, path),
               map[string]interface{}{
                   "data": map[string]interface{}{
                       "metadata": map[string]interface{}{
                           "last_validated": now,
                       },
                   },
               },
           )
           return err
       })
       
       log.Info().Str("user_id", userID).Msg("validated railway token")
       return nil
   }
   ```

## Test Plan

**Objective**: Verify Railway token CRUD operations work correctly with Vault and caching.

**Success Criteria**:
- Store creates new secret in Vault
- Get retrieves token and uses cache
- Delete removes secret and invalidates cache
- Rotate creates new version
- Validate calls Railway API successfully

**Test Steps**:
1. Store a Railway token
2. Retrieve it (should be from cache)
3. Clear cache and retrieve again (from Vault)
4. Rotate to new token
5. Verify new token retrieved
6. Validate token with Railway API
7. Delete token
8. Verify get returns ErrSecretNotFound

## Verification

- [ ] `railway_secrets.go` created
- [ ] StoreRailwayToken implemented
- [ ] GetRailwayToken implemented with caching
- [ ] DeleteRailwayToken implemented with cache invalidation
- [ ] RotateRailwayToken implemented
- [ ] ValidateRailwayToken implemented
- [ ] All operations use circuit breaker
- [ ] Logging added for all operations
- [ ] Code compiles successfully
- [ ] Methods match SecretStore interface

## Files Modified

- `api/internal/vault/railway_secrets.go` (new)
- `api/internal/vault/client.go` (updated to include Railway methods)


# [17-4] Create Vault HTTP client wrapper and implement initialization

[Back to task list](./tasks.md)

## Description

Create a new `vault` package in the Mirage backend with an HTTP client wrapper for interacting with Vault's HTTP API directly. Implement client initialization with configuration loading from environment variables, supporting both development and production modes. This approach avoids using the beta Go SDK and gives us full control over the HTTP interactions.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-09 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |
| 2025-10-09 03:00:00 | Status Change | Proposed | InProgress | Started implementation | AI Agent |
| 2025-10-09 04:00:00 | Status Change | InProgress | Review | Completed vault package, config integration, and main.go initialization | AI Agent |
| 2025-10-09 05:00:00 | Status Change | Review | Done | Approved with error handling and TLS improvements | User |

## Requirements

1. Create `api/internal/vault` package (no external Vault SDK needed)
2. Implement HTTP client wrapper for Vault API
3. Implement `Config` struct for Vault configuration
4. Implement `NewClient()` function for client initialization
5. Support configuration from environment variables
6. Add Vault config to application `config.AppConfig`
7. Initialize Vault client in main.go
8. Add logging for Vault connection status
9. Implement base HTTP request helper methods

## Implementation Plan

### Phase 1: Create Vault Package Structure
1. Create directory: `api/internal/vault/`
2. Create files:
   - `client.go` - HTTP client wrapper and initialization
   - `config.go` - Configuration types and loading
   - `types.go` - Common types and constants
   
Note: No external dependencies needed - we'll use Go's standard `net/http` package

### Phase 2: Implement Configuration
1. Create `Config` struct in `config.go`:
   ```go
   type Config struct {
       Address     string // VAULT_ADDR (e.g., http://localhost:8200)
       Token       string // VAULT_TOKEN (for dev)
       RoleID      string // VAULT_ROLE_ID (for prod AppRole)
       SecretID    string // VAULT_SECRET_ID (for prod AppRole)
       Namespace   string // VAULT_NAMESPACE (optional, Vault Enterprise)
       SkipVerify  bool   // VAULT_SKIP_VERIFY (dev only)
       MountPath   string // Secrets mount path (default: "mirage")
   }
   ```

2. Create `types.go` with common constants:
   ```go
   const (
       DefaultMountPath = "mirage"
       DefaultTimeout   = 30 * time.Second
   )
   ```

3. Add Vault config to `internal/config/config.go`:
   ```go
   type AppConfig struct {
       // ... existing fields ...
       
       // Vault configuration
       VaultEnabled    bool   // VAULT_ENABLED
       VaultAddr       string // VAULT_ADDR
       VaultToken      string // VAULT_TOKEN
       VaultRoleID     string // VAULT_ROLE_ID
       VaultSecretID   string // VAULT_SECRET_ID
       VaultNamespace  string // VAULT_NAMESPACE
       VaultSkipVerify bool   // VAULT_SKIP_VERIFY
       VaultMountPath  string // VAULT_MOUNT_PATH (default: "mirage")
   }
   ```

4. Update `LoadFromEnv()` to load Vault configuration:
   ```go
   VaultEnabled:    getEnvBool("VAULT_ENABLED", false),
   VaultAddr:       os.Getenv("VAULT_ADDR"),
   VaultToken:      os.Getenv("VAULT_TOKEN"),
   VaultRoleID:     os.Getenv("VAULT_ROLE_ID"),
   VaultSecretID:   os.Getenv("VAULT_SECRET_ID"),
   VaultNamespace:  os.Getenv("VAULT_NAMESPACE"),
   VaultSkipVerify: getEnvBool("VAULT_SKIP_VERIFY", false),
   VaultMountPath:  getEnv("VAULT_MOUNT_PATH", "mirage"),
   ```

### Phase 3: Implement HTTP Client Wrapper
1. Create `Client` struct in `client.go`:
   ```go
   type Client struct {
       address    string
       token      string
       httpClient *http.Client
       namespace  string
       mountPath  string
   }
   
   func NewClient(cfg Config) (*Client, error) {
       // Create HTTP client with timeout
       httpClient := &http.Client{
           Timeout: DefaultTimeout,
       }
       
       // Configure TLS if needed
       if cfg.SkipVerify {
           httpClient.Transport = &http.Transport{
               TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
           }
       }
       
       return &Client{
           address:    cfg.Address,
           token:      cfg.Token,
           httpClient: httpClient,
           namespace:  cfg.Namespace,
           mountPath:  cfg.MountPath,
       }, nil
   }
   ```

2. Implement base HTTP request method:
   ```go
   func (c *Client) makeRequest(ctx context.Context, method, path string, body interface{}, result interface{}) error {
       // Create request body if needed
       var reqBody io.Reader
       if body != nil {
           data, err := json.Marshal(body)
           if err != nil {
               return fmt.Errorf("marshal request: %w", err)
           }
           reqBody = bytes.NewReader(data)
       }
       
       // Create HTTP request
       req, err := http.NewRequestWithContext(ctx, method, c.address+path, reqBody)
       if err != nil {
           return fmt.Errorf("create request: %w", err)
       }
       
       // Set headers
       req.Header.Set("X-Vault-Token", c.token)
       if body != nil {
           req.Header.Set("Content-Type", "application/json")
       }
       if c.namespace != "" {
           req.Header.Set("X-Vault-Namespace", c.namespace)
       }
       
       // Execute request
       resp, err := c.httpClient.Do(req)
       if err != nil {
           return fmt.Errorf("execute request: %w", err)
       }
       defer resp.Body.Close()
       
       // Handle error responses
       if resp.StatusCode >= 400 {
           var errResp struct {
               Errors []string `json:"errors"`
           }
           json.NewDecoder(resp.Body).Decode(&errResp)
           return fmt.Errorf("vault error (%d): %v", resp.StatusCode, errResp.Errors)
       }
       
       // Decode response if needed
       if result != nil && resp.StatusCode != 204 {
           if err := json.NewDecoder(resp.Body).Decode(result); err != nil {
               return fmt.Errorf("decode response: %w", err)
           }
       }
       
       return nil
   }
   ```

3. Implement initialization with error handling:
   - Validate configuration (Address required)
   - Create HTTP client with appropriate TLS config
   - Store token and namespace
   - Log initialization

### Phase 4: Integrate with Application
1. Update `cmd/server/main.go`:
   ```go
   var vaultClient *vault.Client
   if cfg.VaultEnabled {
       vaultCfg := vault.Config{
           Address:    cfg.VaultAddr,
           Token:      cfg.VaultToken,
           RoleID:     cfg.VaultRoleID,
           SecretID:   cfg.VaultSecretID,
           Namespace:  cfg.VaultNamespace,
           SkipVerify: cfg.VaultSkipVerify,
           MountPath:  cfg.VaultMountPath,
       }
       vc, err := vault.NewClient(vaultCfg)
       if err != nil {
           log.Warn().Err(err).Msg("failed to initialize Vault client, continuing without Vault")
       } else {
           vaultClient = vc
           log.Info().Msg("Vault client initialized successfully")
       }
   }
   ```

2. Pass vault client to server through deps:
   ```go
   r := server.NewHTTPServer(cfg, db, rw, vaultClient)
   ```

### Phase 5: Add Helper Utility Function
1. Add `getEnvBool` helper to `config.go` if not already present:
   ```go
   func getEnvBool(key string, fallback bool) bool {
       if v := os.Getenv(key); v != "" {
           b, err := strconv.ParseBool(v)
           if err == nil {
               return b
           }
       }
       return fallback
   }
   ```

## Test Plan

**Objective**: Verify Vault HTTP client wrapper initializes correctly and can make basic HTTP requests.

**Success Criteria**:
- Package compiles without errors using only standard library
- Client initializes successfully with dev token
- HTTP request helper method works correctly
- Configuration loads correctly from environment variables
- Application logs show Vault initialization status
- TLS skip verify works for development

**Test Steps**:
1. Compile: `go build ./cmd/server`
2. Start with valid Vault config (docker-compose) and verify initialization log
3. Start with invalid Vault config and verify warning log
4. Start with VAULT_ENABLED=false and verify Vault client is nil
5. Verify HTTP client timeout is set correctly
6. Test makeRequest helper with a simple health check (in next task)

## Verification

- [x] `api/internal/vault/` package created
- [x] `client.go` implements Client struct with HTTP client wrapper
- [x] `client.go` implements makeRequest helper method
- [x] `types.go` implements common constants
- [x] `config.go` implements Config struct
- [x] Vault configuration added to `internal/config/config.go`
- [x] LoadFromEnv loads Vault configuration
- [x] Main.go initializes Vault client when enabled
- [x] Application compiles successfully (no external Vault SDK)
- [x] HTTP client configured with timeout
- [x] TLS skip verify works for development
- [x] Vault initialization logged on startup
- [x] Graceful handling when Vault unavailable

## Files Modified

- `api/internal/vault/client.go` (new)
- `api/internal/vault/config.go` (new)
- `api/internal/vault/types.go` (new)
- `api/internal/config/config.go` (updated)
- `api/cmd/server/main.go` (updated)
- `api/internal/server/server.go` (updated)


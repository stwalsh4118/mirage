# [17-6] Implement health checking and circuit breaker for Vault

[Back to task list](./tasks.md)

## Description

Implement health checking for Vault connectivity and a circuit breaker pattern to prevent cascade failures when Vault is unavailable. Add graceful degradation to allow the application to continue operating with cached secrets when Vault is temporarily unreachable.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-09 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |
| 2025-10-09 07:30:00 | Status Change | Proposed | InProgress | Started circuit breaker and health checking implementation | AI Agent |
| 2025-10-09 08:00:00 | Status Change | InProgress | Review | Completed circuit breaker pattern with health checking | AI Agent |
| 2025-10-09 08:30:00 | Status Change | Review | Done | Approved with shutdown safety fixes from CodeRabbit review | User |

## Requirements

1. Implement Vault health check method
2. Implement circuit breaker pattern for Vault operations
3. Add connection state tracking (connected, degraded, disconnected)
4. Provide health status API
5. Add metrics for Vault connectivity
6. Log connectivity state changes

## Implementation Plan

### Phase 1: Health Check Implementation
1. Add health check method to Client:
   ```go
   func (c *Client) HealthCheck(ctx context.Context) error {
       health, err := c.client.Sys().Health()
       if err != nil {
           return fmt.Errorf("vault health check failed: %w", err)
       }
       
       if health.Sealed {
           return errors.New("vault is sealed")
       }
       
       if !health.Initialized {
           return errors.New("vault is not initialized")
       }
       
       return nil
   }
   ```

2. Add detailed status method:
   ```go
   func (c *Client) GetStatus(ctx context.Context) (VaultStatus, error) {
       health, err := c.client.Sys().Health()
       if err != nil {
           return VaultStatus{Available: false}, err
       }
       
       return VaultStatus{
           Available:   true,
           Initialized: health.Initialized,
           Sealed:      health.Sealed,
           Version:     health.Version,
           ClusterID:   health.ClusterID,
       }, nil
   }
   ```

### Phase 2: Circuit Breaker Implementation
1. Add circuit breaker state tracking:
   ```go
   const (
       CircuitClosed CircuitState = iota
       CircuitOpen
       CircuitHalfOpen
   )
   
   type CircuitBreaker struct {
       state         CircuitState
       failureCount  int
       lastFailure   time.Time
       successCount  int
       threshold     int           // failures before opening
       timeout       time.Duration // time before half-open
       mu            sync.RWMutex
   }
   
   const (
       defaultFailureThreshold = 5
       defaultCircuitTimeout   = 30 * time.Second
       defaultSuccessThreshold = 2
   )
   ```

2. Implement circuit breaker logic:
   ```go
   func (cb *CircuitBreaker) Call(fn func() error) error {
       if !cb.canExecute() {
           return ErrCircuitOpen
       }
       
       err := fn()
       cb.recordResult(err)
       return err
   }
   
   func (cb *CircuitBreaker) canExecute() bool {
       cb.mu.RLock()
       defer cb.mu.RUnlock()
       
       switch cb.state {
       case CircuitClosed:
           return true
       case CircuitOpen:
           if time.Since(cb.lastFailure) > cb.timeout {
               cb.state = CircuitHalfOpen
               return true
           }
           return false
       case CircuitHalfOpen:
           return true
       }
       return false
   }
   
   func (cb *CircuitBreaker) recordResult(err error) {
       cb.mu.Lock()
       defer cb.mu.Unlock()
       
       if err != nil {
           cb.failureCount++
           cb.lastFailure = time.Now()
           cb.successCount = 0
           
           if cb.failureCount >= cb.threshold {
               cb.state = CircuitOpen
               log.Warn().Msg("Vault circuit breaker opened")
           }
       } else {
           cb.successCount++
           
           if cb.state == CircuitHalfOpen && cb.successCount >= defaultSuccessThreshold {
               cb.state = CircuitClosed
               cb.failureCount = 0
               log.Info().Msg("Vault circuit breaker closed")
           }
       }
   }
   ```

3. Add circuit breaker to Client:
   ```go
   type Client struct {
       client        *api.Client
       mountPath     string
       config        Config
       circuitBreaker *CircuitBreaker
   }
   ```

### Phase 3: Wrap Operations with Circuit Breaker
1. Create wrapper method for all Vault operations:
   ```go
   func (c *Client) executeWithCircuitBreaker(ctx context.Context, fn func() error) error {
       return c.circuitBreaker.Call(fn)
   }
   ```

2. Update operations to use circuit breaker (will be implemented in later tasks)

### Phase 4: Health Check Endpoint
1. Create controller method for health check:
   ```go
   func (c *SecretsController) GetVaultHealth(ctx *gin.Context) {
       if c.Vault == nil {
           ctx.JSON(http.StatusOK, gin.H{
               "vault_enabled": false,
           })
           return
       }
       
       status, err := c.Vault.GetStatus(ctx)
       if err != nil {
           ctx.JSON(http.StatusOK, gin.H{
               "vault_reachable": false,
               "error": err.Error(),
           })
           return
       }
       
       circuitState := c.Vault.GetCircuitState()
       ctx.JSON(http.StatusOK, gin.H{
           "vault_reachable": true,
           "sealed": status.Sealed,
           "initialized": status.Initialized,
           "version": status.Version,
           "circuit_state": circuitState,
       })
   }
   ```

### Phase 5: Periodic Health Checking
1. Add background health checker:
   ```go
   func (c *Client) startHealthChecker(ctx context.Context, interval time.Duration) {
       ticker := time.NewTicker(interval)
       defer ticker.Stop()
       
       for {
           select {
           case <-ctx.Done():
               return
           case <-ticker.C:
               if err := c.HealthCheck(ctx); err != nil {
                   log.Warn().Err(err).Msg("Vault health check failed")
               }
           }
       }
   }
   ```

## Test Plan

**Objective**: Verify circuit breaker prevents cascade failures and health checking works correctly.

**Success Criteria**:
- Health check correctly identifies Vault status
- Circuit breaker opens after threshold failures
- Circuit breaker transitions to half-open after timeout
- Circuit breaker closes after successful operations
- Health status endpoint returns accurate information

**Test Steps**:
1. Test health check with healthy Vault
2. Test health check with sealed Vault
3. Test health check with stopped Vault
4. Simulate multiple failures and verify circuit opens
5. Wait for timeout and verify circuit goes half-open
6. Perform successful operation and verify circuit closes

## Verification

- [x] HealthCheck method implemented
- [x] GetStatus method implemented
- [x] VaultStatus type defined
- [x] Circuit breaker state machine implemented
- [x] Circuit breaker integrated into Client
- [x] Circuit state accessible via GetCircuitState method
- [ ] Health check endpoint implemented (deferred - no controller yet)
- [x] Background health checker implemented
- [x] Circuit state changes logged
- [x] Code compiles successfully
- [ ] Tests pass (requires running Vault instance)

## Files Modified

- `api/internal/vault/client.go` (updated - added circuit breaker, health checking, and GetStatus)
- `api/internal/vault/circuit_breaker.go` (new - circuit breaker implementation)
- `api/internal/vault/types.go` (updated - added VaultStatus and CircuitState types)


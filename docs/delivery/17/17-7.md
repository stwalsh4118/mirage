# [17-7] Implement secret caching layer with TTL

[Back to task list](./tasks.md)

## Description

Implement an in-memory caching layer for frequently accessed secrets to reduce Vault API calls and improve performance. Cache entries should have a 5-minute TTL and support explicit invalidation on updates or deletes.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-09 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |

## Requirements

1. Implement in-memory cache with TTL support
2. Default TTL of 5 minutes for all cached secrets
3. Support explicit cache invalidation on updates/deletes
4. Thread-safe cache operations
5. Cache hit/miss metrics
6. Cache size limits to prevent memory issues

## Implementation Plan

### Phase 1: Cache Structure
1. Create cache types in `cache.go`:
   ```go
   const (
       defaultCacheTTL       = 5 * time.Minute
       defaultMaxCacheSize   = 1000
       cacheCleanupInterval  = 1 * time.Minute
   )
   
   type cacheEntry struct {
       value      interface{}
       expiresAt  time.Time
   }
   
   type SecretCache struct {
       entries  map[string]cacheEntry
       mu       sync.RWMutex
       ttl      time.Duration
       maxSize  int
       hits     int64
       misses   int64
   }
   ```

2. Implement cache constructor:
   ```go
   func NewSecretCache(ttl time.Duration, maxSize int) *SecretCache {
       if ttl == 0 {
           ttl = defaultCacheTTL
       }
       if maxSize == 0 {
           maxSize = defaultMaxCacheSize
       }
       
       cache := &SecretCache{
           entries: make(map[string]cacheEntry),
           ttl:     ttl,
           maxSize: maxSize,
       }
       
       go cache.startCleanup()
       return cache
   }
   ```

### Phase 2: Cache Operations
1. Implement Get method:
   ```go
   func (c *SecretCache) Get(key string) (interface{}, bool) {
       c.mu.RLock()
       defer c.mu.RUnlock()
       
       entry, exists := c.entries[key]
       if !exists {
           atomic.AddInt64(&c.misses, 1)
           return nil, false
       }
       
       if time.Now().After(entry.expiresAt) {
           atomic.AddInt64(&c.misses, 1)
           return nil, false
       }
       
       atomic.AddInt64(&c.hits, 1)
       return entry.value, true
   }
   ```

2. Implement Set method:
   ```go
   func (c *SecretCache) Set(key string, value interface{}) error {
       c.mu.Lock()
       defer c.mu.Unlock()
       
       if len(c.entries) >= c.maxSize {
           // Evict oldest entries if at capacity
           c.evictOldest()
       }
       
       c.entries[key] = cacheEntry{
           value:     value,
           expiresAt: time.Now().Add(c.ttl),
       }
       return nil
   }
   ```

3. Implement Delete method:
   ```go
   func (c *SecretCache) Delete(key string) {
       c.mu.Lock()
       defer c.mu.Unlock()
       delete(c.entries, key)
   }
   ```

4. Implement Invalidate method for pattern-based deletion:
   ```go
   func (c *SecretCache) Invalidate(pattern string) {
       c.mu.Lock()
       defer c.mu.Unlock()
       
       for key := range c.entries {
           if strings.HasPrefix(key, pattern) {
               delete(c.entries, key)
           }
       }
   }
   ```

### Phase 3: Cache Cleanup
1. Implement periodic cleanup:
   ```go
   func (c *SecretCache) startCleanup() {
       ticker := time.NewTicker(cacheCleanupInterval)
       defer ticker.Stop()
       
       for range ticker.C {
           c.cleanup()
       }
   }
   
   func (c *SecretCache) cleanup() {
       c.mu.Lock()
       defer c.mu.Unlock()
       
       now := time.Now()
       for key, entry := range c.entries {
           if now.After(entry.expiresAt) {
               delete(c.entries, key)
           }
       }
   }
   ```

2. Implement eviction policy:
   ```go
   func (c *SecretCache) evictOldest() {
       // Find and remove oldest entry (simple LRU approximation)
       var oldestKey string
       var oldestTime time.Time = time.Now()
       
       for key, entry := range c.entries {
           if entry.expiresAt.Before(oldestTime) {
               oldestTime = entry.expiresAt
               oldestKey = key
           }
       }
       
       if oldestKey != "" {
           delete(c.entries, oldestKey)
       }
   }
   ```

### Phase 4: Cache Metrics
1. Implement metrics methods:
   ```go
   func (c *SecretCache) GetStats() CacheStats {
       c.mu.RLock()
       defer c.mu.RUnlock()
       
       hits := atomic.LoadInt64(&c.hits)
       misses := atomic.LoadInt64(&c.misses)
       total := hits + misses
       
       hitRate := float64(0)
       if total > 0 {
           hitRate = float64(hits) / float64(total)
       }
       
       return CacheStats{
           Size:    len(c.entries),
           Hits:    hits,
           Misses:  misses,
           HitRate: hitRate,
       }
   }
   ```

### Phase 5: Integrate Cache with Client
1. Add cache to Client struct:
   ```go
   type Client struct {
       client         *api.Client
       mountPath      string
       config         Config
       circuitBreaker *CircuitBreaker
       cache          *SecretCache
   }
   ```

2. Initialize cache in NewClient:
   ```go
   cache := NewSecretCache(5*time.Minute, defaultMaxCacheSize)
   ```

3. Helper methods for cache key generation:
   ```go
   func (c *Client) makeCacheKey(userID, path string) string {
       return fmt.Sprintf("%s:%s", userID, path)
   }
   ```

## Test Plan

**Objective**: Verify caching reduces Vault calls and maintains data consistency.

**Success Criteria**:
- Cache stores and retrieves values correctly
- TTL expiration works as expected
- Explicit invalidation removes entries
- Cache metrics track hits and misses accurately
- Thread-safe under concurrent access
- Memory bounded by maxSize

**Test Steps**:
1. Set value and retrieve immediately (cache hit)
2. Wait for TTL expiration and verify miss
3. Test explicit invalidation
4. Test pattern-based invalidation
5. Verify cache size limit enforcement
6. Test concurrent access from multiple goroutines

## Verification

- [ ] SecretCache type implemented
- [ ] Get/Set/Delete methods implemented
- [ ] TTL expiration working
- [ ] Invalidate method for pattern-based deletion
- [ ] Periodic cleanup implemented
- [ ] Cache eviction when at capacity
- [ ] Cache metrics methods implemented
- [ ] Cache integrated into Vault Client
- [ ] Cache key generation helpers added
- [ ] Code compiles successfully
- [ ] Thread-safety verified

## Files Modified

- `api/internal/vault/cache.go` (new)
- `api/internal/vault/client.go` (updated)


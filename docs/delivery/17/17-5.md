# [17-5] Implement Vault authentication with token and AppRole

[Back to task list](./tasks.md)

## Description

Implement authentication mechanisms for Vault: token-based authentication for development and AppRole authentication for production. Add automatic token renewal to prevent token expiration during runtime.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-09 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |
| 2025-10-09 06:00:00 | Status Change | Proposed | InProgress | Started authentication implementation | AI Agent |
| 2025-10-09 06:30:00 | Status Change | InProgress | Review | Completed token and AppRole auth with automatic renewal | AI Agent |
| 2025-10-09 07:00:00 | Status Change | Review | Done | Approved with concurrency fixes from CodeRabbit review | User |

## Requirements

1. Implement token-based authentication for development
2. Implement AppRole authentication for production
3. Add automatic token renewal mechanism
4. Handle authentication failures gracefully
5. Add logging for authentication events
6. Support switching between auth methods based on configuration

## Implementation Plan

### Phase 1: Token Authentication
1. Implement `authenticateWithToken()` in `client.go`:
   ```go
   func (c *Client) authenticateWithToken(token string) error {
       c.client.SetToken(token)
       // Test token by reading self info
       _, err := c.client.Auth().Token().LookupSelf()
       return err
   }
   ```

### Phase 2: AppRole Authentication
1. Implement `authenticateWithAppRole()` in `client.go`:
   ```go
   func (c *Client) authenticateWithAppRole(roleID, secretID string) error {
       // Login using AppRole
       secret, err := c.client.Logical().Write("auth/approle/login", map[string]interface{}{
           "role_id":   roleID,
           "secret_id": secretID,
       })
       if err != nil {
           return err
       }
       
       c.client.SetToken(secret.Auth.ClientToken)
       return nil
   }
   ```

### Phase 3: Authentication Selection Logic
1. Update `NewClient()` to select auth method:
   ```go
   func NewClient(cfg Config) (*Client, error) {
       // ... existing setup ...
       
       if cfg.Token != "" {
           // Use token auth (development)
           if err := client.authenticateWithToken(cfg.Token); err != nil {
               return nil, fmt.Errorf("token authentication failed: %w", err)
           }
           log.Info().Msg("authenticated with Vault using token")
       } else if cfg.RoleID != "" && cfg.SecretID != "" {
           // Use AppRole auth (production)
           if err := client.authenticateWithAppRole(cfg.RoleID, cfg.SecretID); err != nil {
               return nil, fmt.Errorf("AppRole authentication failed: %w", err)
           }
           log.Info().Msg("authenticated with Vault using AppRole")
       } else {
           return nil, errors.New("no valid authentication method configured")
       }
       
       return client, nil
   }
   ```

### Phase 4: Token Renewal
1. Implement token renewal watcher:
   ```go
   func (c *Client) startTokenRenewal(ctx context.Context) {
       // Get token info to check if renewable
       secret, err := c.client.Auth().Token().LookupSelf()
       if err != nil {
           log.Error().Err(err).Msg("failed to lookup token for renewal")
           return
       }
       
       renewable, _ := secret.Data["renewable"].(bool)
       if !renewable {
           log.Warn().Msg("Vault token is not renewable")
           return
       }
       
       // Start renewal watcher
       watcher, err := c.client.NewLifetimeWatcher(&api.LifetimeWatcherInput{
           Secret: secret,
       })
       if err != nil {
           log.Error().Err(err).Msg("failed to create token renewal watcher")
           return
       }
       
       go watcher.Start()
       defer watcher.Stop()
       
       for {
           select {
           case <-ctx.Done():
               return
           case err := <-watcher.DoneCh():
               if err != nil {
                   log.Error().Err(err).Msg("token renewal failed")
               }
               return
           case renewal := <-watcher.RenewCh():
               log.Info().Msg("Vault token renewed successfully")
           }
       }
   }
   ```

2. Start renewal in NewClient:
   ```go
   // Start token renewal in background
   go client.startTokenRenewal(context.Background())
   ```

## Test Plan

**Objective**: Verify both authentication methods work correctly and tokens renew automatically.

**Success Criteria**:
- Token authentication works in development
- AppRole authentication works in production
- Token renewal happens before expiration
- Authentication failures logged appropriately
- Invalid credentials rejected with clear errors

**Test Steps**:
1. Test token auth with valid dev token
2. Test token auth with invalid token (should fail)
3. Test AppRole auth with valid RoleID/SecretID
4. Test AppRole auth with invalid credentials (should fail)
5. Verify token renewal log messages appear

## Verification

- [x] Token authentication implemented
- [x] AppRole authentication implemented
- [x] Authentication method selection logic in NewClient
- [x] Token renewal watcher implemented
- [x] Renewal started automatically after authentication
- [x] Authentication failures handled gracefully
- [x] Authentication events logged
- [x] Code compiles successfully
- [ ] Both auth methods tested (requires running Vault instance)

## Files Modified

- `api/internal/vault/client.go` (updated - added authentication and renewal methods)
- `api/internal/vault/types.go` (updated - added auth-related types)


# [17-10] Implement GitHub token management in SecretStore

[Back to task list](./tasks.md)

## Description

Implement GitHub Personal Access Token (PAT) management methods in the Vault SecretStore: store, get, delete, and validate GitHub tokens for private repository access.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-09 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |
| 2025-10-10 00:00:00 | Status Change | Proposed | InProgress | Starting implementation with new token helper pattern | AI Agent |
| 2025-10-10 00:00:00 | Status Change | InProgress | Review | Implementation complete, ready for review | AI Agent |
| 2025-10-10 00:00:00 | Status Change | Review | Done | CodeRabbit review issues addressed, all tests pass | AI Agent |

## Requirements

1. Implement `StoreGitHubToken` - Store GitHub PAT with metadata ✅
2. Implement `GetGitHubToken` - Retrieve GitHub PAT ✅
3. Implement `DeleteGitHubToken` - Remove GitHub PAT ✅
4. Implement `validateGitHubToken` (internal helper) - Test token validity with GitHub API ✅
5. Use Vault KV v2 API for versioned storage ✅
6. Integrate with caching layer (deferred to task 17-7)
7. Add logging for all operations ✅

**Note**: Implementation uses new generic token helper pattern established in railway_secrets.go refactoring. Caching integration will be added when task 17-7 (secret caching layer) is implemented.

## Implementation Summary

The implementation follows the new pattern established with the Railway token refactoring:

1. **Generic Helpers Used**: All CRUD operations use the generic `storeTokenSecret`, `getTokenSecret`, and `deleteTokenSecret` helpers from `token_helpers.go`
2. **Consistent Pattern**: Each public method validates inputs, calls the generic helper with GitHub-specific constants (`BuildGitHubTokenPath`, `SecretTypeGitHub`), and adds provider-specific logging
3. **Validation**: Implemented `validateGitHubToken` internal helper that validates tokens against GitHub's API (`GET /user`) and extracts username + scopes
4. **Metadata Tracking**: Includes `ValidateGitHubTokenAndUpdateMetadata` method that validates token and updates Vault metadata with validation timestamp, username, and scopes

### Key Implementation Details

**StoreGitHubToken**:
- Validates userID and token inputs
- Uses `storeTokenSecret` helper with GitHub path and secret type
- Logs successful storage with user_id and secret_path

**GetGitHubToken**:
- Validates userID input
- Uses `getTokenSecret` helper with GitHub path
- Returns ErrSecretNotFound if token doesn't exist
- Logs retrieval with debug level

**DeleteGitHubToken**:
- Validates userID input  
- Uses `deleteTokenSecret` helper with GitHub path
- Returns ErrSecretNotFound if token doesn't exist
- Logs deletion

**validateGitHubToken** (internal):
- Makes authenticated request to GitHub API `/user` endpoint
- Uses Bearer token authentication
- Extracts username from response body
- Extracts token scopes from `X-OAuth-Scopes` header
- Returns username, scopes, and any errors

**ValidateGitHubTokenAndUpdateMetadata**:
- Gets token from Vault
- Validates via GitHub API
- Updates Vault metadata with last_validated timestamp, github_username, and github_scopes
- Follows same pattern as Railway token validation

## Original Implementation Plan (for reference)

### Phase 1: StoreGitHubToken
1. Implement in `github_secrets.go`:
   ```go
   func (c *Client) StoreGitHubToken(ctx context.Context, userID, token string) error {
       if token == "" {
           return ErrInvalidSecret
       }
       
       path := BuildSecretPath(c.mountPath, userID, PathGitHub)
       metadata := SecretMetadata{
           CreatedBy:  userID,
           CreatedAt:  time.Now(),
           SecretType: SecretTypeGitHub,
       }
       
       data := map[string]interface{}{
           "token":    token,
           "metadata": metadata,
       }
       
       err := c.executeWithCircuitBreaker(ctx, func() error {
           _, err := c.client.Logical().Write(
               fmt.Sprintf("%s/data/%s", c.mountPath, path),
               map[string]interface{}{"data": data},
           )
           return err
       })
       
       if err != nil {
           return fmt.Errorf("failed to store github token: %w", err)
       }
       
       // Cache the token
       cacheKey := c.makeCacheKey(userID, PathGitHub)
       c.cache.Set(cacheKey, token)
       
       log.Info().Str("user_id", userID).Msg("stored github token")
       return nil
   }
   ```

### Phase 2: GetGitHubToken
1. Implement with cache-first strategy:
   ```go
   func (c *Client) GetGitHubToken(ctx context.Context, userID string) (string, error) {
       // Check cache first
       cacheKey := c.makeCacheKey(userID, PathGitHub)
       if cached, found := c.cache.Get(cacheKey); found {
           log.Debug().Str("user_id", userID).Msg("github token cache hit")
           return cached.(string), nil
       }
       
       // Fetch from Vault
       path := BuildSecretPath(c.mountPath, userID, PathGitHub)
       var secret *api.Secret
       
       err := c.executeWithCircuitBreaker(ctx, func() error {
           var err error
           secret, err = c.client.Logical().Read(
               fmt.Sprintf("%s/data/%s", c.mountPath, path),
           )
           return err
       })
       
       if err != nil {
           return "", fmt.Errorf("failed to read github token: %w", err)
       }
       
       if secret == nil || secret.Data == nil {
           return "", ErrSecretNotFound
       }
       
       data, ok := secret.Data["data"].(map[string]interface{})
       if !ok {
           return "", errors.New("invalid secret data format")
       }
       
       token, ok := data["token"].(string)
       if !ok {
           return "", errors.New("token not found in secret")
       }
       
       // Update cache
       c.cache.Set(cacheKey, token)
       
       log.Debug().Str("user_id", userID).Msg("retrieved github token from vault")
       return token, nil
   }
   ```

### Phase 3: DeleteGitHubToken
1. Implement deletion with cache invalidation:
   ```go
   func (c *Client) DeleteGitHubToken(ctx context.Context, userID string) error {
       path := BuildSecretPath(c.mountPath, userID, PathGitHub)
       
       err := c.executeWithCircuitBreaker(ctx, func() error {
           _, err := c.client.Logical().Delete(
               fmt.Sprintf("%s/data/%s", c.mountPath, path),
           )
           return err
       })
       
       if err != nil {
           return fmt.Errorf("failed to delete github token: %w", err)
       }
       
       // Invalidate cache
       cacheKey := c.makeCacheKey(userID, PathGitHub)
       c.cache.Delete(cacheKey)
       
       log.Info().Str("user_id", userID).Msg("deleted github token")
       return nil
   }
   ```

### Phase 4: ValidateGitHubToken (Helper)
1. Implement validation by calling GitHub API:
   ```go
   func (c *Client) validateGitHubToken(ctx context.Context, token string) (string, []string, error) {
       req, err := http.NewRequestWithContext(
           ctx,
           "GET",
           "https://api.github.com/user",
           nil,
       )
       if err != nil {
           return "", nil, err
       }
       
       req.Header.Set("Authorization", "Bearer "+token)
       req.Header.Set("Accept", "application/vnd.github+json")
       
       resp, err := http.DefaultClient.Do(req)
       if err != nil {
           return "", nil, fmt.Errorf("github api request failed: %w", err)
       }
       defer resp.Body.Close()
       
       if resp.StatusCode != http.StatusOK {
           return "", nil, fmt.Errorf("github token invalid: status %d", resp.StatusCode)
       }
       
       var user struct {
           Login string `json:"login"`
       }
       if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
           return "", nil, err
       }
       
       // Extract scopes from response headers
       scopes := strings.Split(resp.Header.Get("X-OAuth-Scopes"), ", ")
       
       return user.Login, scopes, nil
   }
   ```

## Test Plan

**Objective**: Verify GitHub token CRUD operations work correctly with Vault and caching.

**Success Criteria**:
- Store creates new secret in Vault
- Get retrieves token and uses cache
- Delete removes secret and invalidates cache
- Validation detects valid and invalid tokens

**Test Steps**:
1. Store a GitHub token
2. Retrieve it (should be from cache)
3. Clear cache and retrieve again (from Vault)
4. Delete token
5. Verify get returns ErrSecretNotFound
6. Test validation with valid token
7. Test validation with invalid token

## Verification

- [x] `github_secrets.go` created
- [x] StoreGitHubToken implemented using generic helper pattern
- [x] GetGitHubToken implemented (caching deferred to task 17-7)
- [x] DeleteGitHubToken implemented using generic helper pattern
- [x] validateGitHubToken internal helper implemented with GitHub API integration
- [x] ValidateGitHubTokenAndUpdateMetadata implemented for metadata tracking
- [x] All operations use consistent error handling
- [x] Logging added for all operations (Info for mutations, Debug for reads)
- [x] Code compiles successfully
- [x] Methods match SecretStore interface

## Files Modified

- `api/internal/vault/github_secrets.go` (new) - 226 lines
- Uses existing `token_helpers.go` generic functions


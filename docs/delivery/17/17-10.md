# [17-10] Implement GitHub token management in SecretStore

[Back to task list](./tasks.md)

## Description

Implement GitHub Personal Access Token (PAT) management methods in the Vault SecretStore: store, get, delete, and validate GitHub tokens for private repository access.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-09 00:00:00 | Created | N/A | Proposed | Task file created | AI Agent |

## Requirements

1. Implement `StoreGitHubToken` - Store GitHub PAT with metadata
2. Implement `GetGitHubToken` - Retrieve GitHub PAT with caching
3. Implement `DeleteGitHubToken` - Remove GitHub PAT and invalidate cache
4. Implement `ValidateGitHubToken` (internal helper) - Test token validity with GitHub API
5. Use Vault KV v2 API for versioned storage
6. Integrate with caching layer
7. Add logging for all operations

## Implementation Plan

### Phase 1: StoreGitHubToken
1. Implement in `github_secrets.go`:
   ```go
   func (c *Client) StoreGitHubToken(ctx context.Context, userID, token string) error {
       if token == "" {
           return ErrInvalidSecret
       }
       
       path := BuildSecretPath(c.mountPath, userID, PathGitHub)
       metadata := SecretMetadata{
           CreatedBy:  userID,
           CreatedAt:  time.Now(),
           SecretType: SecretTypeGitHub,
       }
       
       data := map[string]interface{}{
           "token":    token,
           "metadata": metadata,
       }
       
       err := c.executeWithCircuitBreaker(ctx, func() error {
           _, err := c.client.Logical().Write(
               fmt.Sprintf("%s/data/%s", c.mountPath, path),
               map[string]interface{}{"data": data},
           )
           return err
       })
       
       if err != nil {
           return fmt.Errorf("failed to store github token: %w", err)
       }
       
       // Cache the token
       cacheKey := c.makeCacheKey(userID, PathGitHub)
       c.cache.Set(cacheKey, token)
       
       log.Info().Str("user_id", userID).Msg("stored github token")
       return nil
   }
   ```

### Phase 2: GetGitHubToken
1. Implement with cache-first strategy:
   ```go
   func (c *Client) GetGitHubToken(ctx context.Context, userID string) (string, error) {
       // Check cache first
       cacheKey := c.makeCacheKey(userID, PathGitHub)
       if cached, found := c.cache.Get(cacheKey); found {
           log.Debug().Str("user_id", userID).Msg("github token cache hit")
           return cached.(string), nil
       }
       
       // Fetch from Vault
       path := BuildSecretPath(c.mountPath, userID, PathGitHub)
       var secret *api.Secret
       
       err := c.executeWithCircuitBreaker(ctx, func() error {
           var err error
           secret, err = c.client.Logical().Read(
               fmt.Sprintf("%s/data/%s", c.mountPath, path),
           )
           return err
       })
       
       if err != nil {
           return "", fmt.Errorf("failed to read github token: %w", err)
       }
       
       if secret == nil || secret.Data == nil {
           return "", ErrSecretNotFound
       }
       
       data, ok := secret.Data["data"].(map[string]interface{})
       if !ok {
           return "", errors.New("invalid secret data format")
       }
       
       token, ok := data["token"].(string)
       if !ok {
           return "", errors.New("token not found in secret")
       }
       
       // Update cache
       c.cache.Set(cacheKey, token)
       
       log.Debug().Str("user_id", userID).Msg("retrieved github token from vault")
       return token, nil
   }
   ```

### Phase 3: DeleteGitHubToken
1. Implement deletion with cache invalidation:
   ```go
   func (c *Client) DeleteGitHubToken(ctx context.Context, userID string) error {
       path := BuildSecretPath(c.mountPath, userID, PathGitHub)
       
       err := c.executeWithCircuitBreaker(ctx, func() error {
           _, err := c.client.Logical().Delete(
               fmt.Sprintf("%s/data/%s", c.mountPath, path),
           )
           return err
       })
       
       if err != nil {
           return fmt.Errorf("failed to delete github token: %w", err)
       }
       
       // Invalidate cache
       cacheKey := c.makeCacheKey(userID, PathGitHub)
       c.cache.Delete(cacheKey)
       
       log.Info().Str("user_id", userID).Msg("deleted github token")
       return nil
   }
   ```

### Phase 4: ValidateGitHubToken (Helper)
1. Implement validation by calling GitHub API:
   ```go
   func (c *Client) validateGitHubToken(ctx context.Context, token string) (string, []string, error) {
       req, err := http.NewRequestWithContext(
           ctx,
           "GET",
           "https://api.github.com/user",
           nil,
       )
       if err != nil {
           return "", nil, err
       }
       
       req.Header.Set("Authorization", "Bearer "+token)
       req.Header.Set("Accept", "application/vnd.github+json")
       
       resp, err := http.DefaultClient.Do(req)
       if err != nil {
           return "", nil, fmt.Errorf("github api request failed: %w", err)
       }
       defer resp.Body.Close()
       
       if resp.StatusCode != http.StatusOK {
           return "", nil, fmt.Errorf("github token invalid: status %d", resp.StatusCode)
       }
       
       var user struct {
           Login string `json:"login"`
       }
       if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
           return "", nil, err
       }
       
       // Extract scopes from response headers
       scopes := strings.Split(resp.Header.Get("X-OAuth-Scopes"), ", ")
       
       return user.Login, scopes, nil
   }
   ```

## Test Plan

**Objective**: Verify GitHub token CRUD operations work correctly with Vault and caching.

**Success Criteria**:
- Store creates new secret in Vault
- Get retrieves token and uses cache
- Delete removes secret and invalidates cache
- Validation detects valid and invalid tokens

**Test Steps**:
1. Store a GitHub token
2. Retrieve it (should be from cache)
3. Clear cache and retrieve again (from Vault)
4. Delete token
5. Verify get returns ErrSecretNotFound
6. Test validation with valid token
7. Test validation with invalid token

## Verification

- [ ] `github_secrets.go` created
- [ ] StoreGitHubToken implemented
- [ ] GetGitHubToken implemented with caching
- [ ] DeleteGitHubToken implemented with cache invalidation
- [ ] validateGitHubToken helper implemented
- [ ] All operations use circuit breaker
- [ ] Logging added for all operations
- [ ] Code compiles successfully
- [ ] Methods match SecretStore interface

## Files Modified

- `api/internal/vault/github_secrets.go` (new)
- `api/internal/vault/client.go` (updated to include GitHub methods)

